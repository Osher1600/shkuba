<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/dinari/shkuba/GameViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/dinari/shkuba/GameViewModel.kt" />
              <option name="originalContent" value="package com.dinari.shkuba&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.delay&#10;&#10;data class GameUIState(&#10;    val isGameActive: Boolean = false,&#10;    val currentPlayer: Int = Round.P1,&#10;    val playerHand: List&lt;CardGui&gt; = emptyList(),&#10;    val botHand: List&lt;CardGui&gt; = emptyList(),&#10;    val tableCards: List&lt;CardGui&gt; = emptyList(),&#10;    val gameScore: Pair&lt;Int, Int&gt; = Pair(0, 0), // (P1, P2)&#10;    val roundScore: Pair&lt;Int, Int&gt; = Pair(0, 0), // (P1, P2)&#10;    val gameMessage: String = &quot;&quot;,&#10;    val isPlayerTurn: Boolean = true,&#10;    val gamePhase: GamePhase = GamePhase.NOT_STARTED,&#10;    val winner: String? = null&#10;)&#10;&#10;enum class GamePhase {&#10;    NOT_STARTED,&#10;    FIRST_MINI_ROUND,&#10;    PLAYING_CARDS,&#10;    GIVING_CARDS,&#10;    ROUND_COMPLETE,&#10;    GAME_OVER&#10;}&#10;&#10;class GameViewModel : ViewModel() {&#10;    private val _uiState = MutableStateFlow(GameUIState())&#10;    val uiState: StateFlow&lt;GameUIState&gt; = _uiState.asStateFlow()&#10;&#10;    private var game: Game = Game()&#10;    private var currentRound: Round? = null&#10;    private var deck: Deck = Deck()&#10;    private var playerHand: Hand = Hand()&#10;    private var botHand: Hand = Hand()&#10;    private var board: Board = Board()&#10;    private var gameBot: GameBot = GameBot()&#10;&#10;    fun startNewGame() {&#10;        viewModelScope.launch {&#10;            // Reset game state&#10;            game = Game()&#10;            startNewRound()&#10;        }&#10;    }&#10;&#10;    private suspend fun startNewRound() {&#10;        try {&#10;            // Check if native library is loaded&#10;            if (!com.shkuba.MainActivity.isLibraryLoaded()) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error: Native library not loaded. Cannot start game.&quot;)&#10;                }&#10;                return&#10;            }&#10;            &#10;            // Create new round with current first player&#10;            currentRound = game.createNewRound()&#10;            &#10;            // Create new deck and shuffle&#10;            deck = Deck()&#10;            deck.shuffle()&#10;            &#10;            // Reset hands and board&#10;            playerHand = Hand()&#10;            botHand = Hand()&#10;            board = Board()&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    isGameActive = true,&#10;                    gamePhase = GamePhase.FIRST_MINI_ROUND,&#10;                    currentPlayer = game.getFirstPlayer(),&#10;                    gameScore = Pair(game.getP1Points(), game.getP2Points()),&#10;                    gameMessage = &quot;Starting new round...&quot;&#10;                )&#10;            }&#10;            &#10;            // Execute first mini round&#10;            executeFirstMiniRound()&#10;            &#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not found - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error starting round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun executeFirstMiniRound() {&#10;        try {&#10;            currentRound?.firstMiniRound(true) // Choice parameter - can be made configurable&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    gamePhase = GamePhase.PLAYING_CARDS,&#10;                    gameMessage = &quot;First mini round complete. Starting card play...&quot;&#10;                )&#10;            }&#10;            &#10;            // Give initial cards to players&#10;            giveCardsToPlayers()&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error in first mini round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun giveCardsToPlayers() {&#10;        try {&#10;            currentRound?.giveCardsToPlayers()&#10;            &#10;            // Deal cards from deck to hands (3 cards each as per NUM_OF_HAND)&#10;            repeat(3) {&#10;                // Deal to player&#10;                val playerCardData = deck.dealCard()&#10;                if (playerCardData.size &gt;= 2) {&#10;                    playerHand.addCard(playerCardData[0], playerCardData[1])&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data from deck&quot;)&#10;                    }&#10;                    return&#10;                }&#10;                &#10;                // Deal to bot&#10;                val botCardData = deck.dealCard()&#10;                if (botCardData.size &gt;= 2) {&#10;                    botHand.addCard(botCardData[0], botCardData[1])  &#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data from deck&quot;)&#10;                    }&#10;                    return&#10;                }&#10;            }&#10;            &#10;            // Add cards to board (4 cards as per NUM_OF_BOARD)&#10;            repeat(4) {&#10;                val cardData = deck.dealCard()&#10;                if (cardData.size &gt;= 2) {&#10;                    board.addToBoard(cardData[0], cardData[1])&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data for board&quot;)&#10;                    }&#10;                    return&#10;                }&#10;            }&#10;            &#10;            updateGameUI()&#10;            &#10;            // Start player turns&#10;            if (game.getFirstPlayer() == Round.P1) {&#10;                updateUIState {&#10;                    it.copy(&#10;                        isPlayerTurn = true,&#10;                        gameMessage = &quot;Your turn! Play a card or drop one.&quot;&#10;                    )&#10;                }&#10;            } else {&#10;                processBotTurn()&#10;            }&#10;            &#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not available - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error giving cards: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun playCard(cardGui: CardGui) {&#10;        viewModelScope.launch {&#10;            if (!_uiState.value.isPlayerTurn || _uiState.value.gamePhase != GamePhase.PLAYING_CARDS) {&#10;                return@launch&#10;            }&#10;&#10;            try {&#10;                // Find card index in player hand&#10;                val cardIndex = findCardIndexInHand(cardGui, playerHand)&#10;                if (cardIndex == -1) {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Card not found in hand&quot;)&#10;                    }&#10;                    return@launch&#10;                }&#10;&#10;                // Try to play the card (simplified - empty cardsToTake for now)&#10;                val result = playerHand.playCard(cardIndex, intArrayOf(), board)&#10;&#10;                if (result == Hand.STATUS_OK) {&#10;                    updateUIState {&#10;                        it.copy(&#10;                            gameMessage = &quot;Card played successfully!&quot;,&#10;                            isPlayerTurn = false&#10;                        )&#10;                    }&#10;&#10;                    updateGameUI()&#10;                    checkHandsAndContinue()&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Cannot play this card. Try dropping it instead.&quot;)&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error playing card: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun dropCard(cardGui: CardGui) {&#10;        viewModelScope.launch {&#10;            if (!_uiState.value.isPlayerTurn || _uiState.value.gamePhase != GamePhase.PLAYING_CARDS) {&#10;                return@launch&#10;            }&#10;            &#10;            try {&#10;                val cardIndex = findCardIndexInHand(cardGui, playerHand)&#10;                if (cardIndex == -1) {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Card not found in hand&quot;)&#10;                    }&#10;                    return@launch&#10;                }&#10;                &#10;                val result = playerHand.dropCard(cardIndex, board)&#10;                &#10;                if (result == Hand.STATUS_OK) {&#10;                    updateUIState {&#10;                        it.copy(&#10;                            gameMessage = &quot;Card dropped to table&quot;,&#10;                            isPlayerTurn = false&#10;                        )&#10;                    }&#10;                    &#10;                    updateGameUI()&#10;                    checkHandsAndContinue()&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Cannot drop card&quot;)&#10;                    }&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error dropping card: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun processBotTurn() {&#10;        updateUIState {&#10;            it.copy(&#10;                gameMessage = &quot;Bot is thinking...&quot;,&#10;                isPlayerTurn = false&#10;            )&#10;        }&#10;        &#10;        delay(1000) // Add delay for better UX&#10;        &#10;        try {&#10;            val botMove = gameBot.makeMove(botHand, board)&#10;            &#10;            when (botMove) {&#10;                is GameBot.BotMove.PlayCard -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot played a card&quot;)&#10;                    }&#10;                }&#10;                is GameBot.BotMove.DropCard -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot dropped a card&quot;)&#10;                    }&#10;                }&#10;                is GameBot.BotMove.NoMove -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot has no moves&quot;)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            updateGameUI()&#10;            checkHandsAndContinue()&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error in bot turn: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun checkHandsAndContinue() {&#10;        val playerHandSize = playerHand.getHandSize()&#10;        val botHandSize = botHand.getHandSize()&#10;        &#10;        if (playerHandSize == 0 &amp;&amp; botHandSize == 0) {&#10;            // Both hands empty - give new cards or end round&#10;            if (deckHasCards()) {&#10;                updateUIState {&#10;                    it.copy(&#10;                        gamePhase = GamePhase.GIVING_CARDS,&#10;                        gameMessage = &quot;Hands empty, dealing new cards...&quot;&#10;                    )&#10;                }&#10;                delay(1000)&#10;                giveCardsToPlayers()&#10;            } else {&#10;                // Deck is empty - end round&#10;                endRound()&#10;            }&#10;        } else {&#10;            // Continue with next player turn&#10;            val nextPlayerTurn = !_uiState.value.isPlayerTurn&#10;            updateUIState {&#10;                it.copy(isPlayerTurn = nextPlayerTurn)&#10;            }&#10;            &#10;            if (!nextPlayerTurn) {&#10;                // Bot's turn&#10;                delay(500)&#10;                processBotTurn()&#10;            } else {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Your turn!&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun endRound() {&#10;        try {&#10;            currentRound?.countPiles()&#10;            &#10;            val roundP1Points = currentRound?.getP1Points() ?: 0&#10;            val roundP2Points = currentRound?.getP2Points() ?: 0&#10;            &#10;            game.addToP1Points(roundP1Points)&#10;            game.addToP2Points(roundP2Points)&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    gamePhase = GamePhase.ROUND_COMPLETE,&#10;                    roundScore = Pair(roundP1Points, roundP2Points),&#10;                    gameScore = Pair(game.getP1Points(), game.getP2Points()),&#10;                    gameMessage = &quot;Round complete! P1: $roundP1Points, P2: $roundP2Points&quot;&#10;                )&#10;            }&#10;            &#10;            delay(2000)&#10;            &#10;            if (game.isGameOver()) {&#10;                endGame()&#10;            } else {&#10;                // Change first player and start new round&#10;                game.changeFirstPlayer()&#10;                startNewRound()&#10;            }&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error ending round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endGame() {&#10;        val winner = game.getWinner()&#10;        updateUIState {&#10;            it.copy(&#10;                gamePhase = GamePhase.GAME_OVER,&#10;                winner = winner,&#10;                gameMessage = &quot;Game Over! Winner: ${winner ?: &quot;Tie&quot;}&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun findCardIndexInHand(cardGui: CardGui, hand: Hand): Int {&#10;        val handSize = hand.getHandSize()&#10;        for (i in 0 until handSize) {&#10;            val handCard = hand.getCardAsNativeCard(i)&#10;            if (handCard != null &amp;&amp; CardConverter.cardGuiMatchesNativeCard(cardGui, handCard)) {&#10;                return i&#10;            }&#10;        }&#10;        return -1&#10;    }&#10;&#10;    private fun updateGameUI() {&#10;        try {&#10;            val playerCards = playerHand.getAllCards().map { CardConverter.nativeCardToCardGui(it) }&#10;            val botCards = botHand.getAllCards().map { CardConverter.nativeCardToCardGui(it) }&#10;            val tableCards = board.getBoard().map { CardConverter.nativeCardToCardGui(it) }&#10;            &#10;            updateUIState { currentState -&gt;&#10;                currentState.copy(&#10;                    playerHand = playerCards,&#10;                    botHand = botCards,&#10;                    tableCards = tableCards&#10;                )&#10;            }&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not available for UI update - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error updating game UI: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun deckHasCards(): Boolean {&#10;        return try {&#10;            deck.getDeckSize() &gt; 0&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            // If native method fails, assume no cards&#10;            false&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    private inline fun updateUIState(update: (GameUIState) -&gt; GameUIState) {&#10;        _uiState.value = update(_uiState.value)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.dinari.shkuba&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.delay&#10;&#10;data class GameUIState(&#10;    val isGameActive: Boolean = false,&#10;    val currentPlayer: Int = Round.P1,&#10;    val playerHand: List&lt;CardGui&gt; = emptyList(),&#10;    val botHand: List&lt;CardGui&gt; = emptyList(),&#10;    val tableCards: List&lt;CardGui&gt; = emptyList(),&#10;    val gameScore: Pair&lt;Int, Int&gt; = Pair(0, 0), // (P1, P2)&#10;    val roundScore: Pair&lt;Int, Int&gt; = Pair(0, 0), // (P1, P2)&#10;    val gameMessage: String = &quot;&quot;,&#10;    val isPlayerTurn: Boolean = true,&#10;    val gamePhase: GamePhase = GamePhase.NOT_STARTED,&#10;    val winner: String? = null&#10;)&#10;&#10;enum class GamePhase {&#10;    NOT_STARTED,&#10;    FIRST_MINI_ROUND,&#10;    PLAYING_CARDS,&#10;    GIVING_CARDS,&#10;    ROUND_COMPLETE,&#10;    GAME_OVER&#10;}&#10;&#10;class GameViewModel : ViewModel() {&#10;    private val _uiState = MutableStateFlow(GameUIState())&#10;    val uiState: StateFlow&lt;GameUIState&gt; = _uiState.asStateFlow()&#10;&#10;    private var game: Game = Game()&#10;    private var currentRound: Round? = null&#10;    private var deck: Deck = Deck()&#10;    private var playerHand: Hand = Hand()&#10;    private var botHand: Hand = Hand()&#10;    private var board: Board = Board()&#10;    private var gameBot: GameBot = GameBot()&#10;&#10;    fun startNewGame() {&#10;        viewModelScope.launch {&#10;            // Reset game state&#10;            game = Game()&#10;            startNewRound()&#10;        }&#10;    }&#10;&#10;    private suspend fun startNewRound() {&#10;        try {&#10;            // Check if native library is loaded&#10;            if (!com.shkuba.MainActivity.isLibraryLoaded()) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error: Native library not loaded. Cannot start game.&quot;)&#10;                }&#10;                return&#10;            }&#10;            &#10;            // Create new round with current first player&#10;            currentRound = game.createNewRound()&#10;            &#10;            // Create new deck and shuffle&#10;            deck = Deck()&#10;            deck.shuffle()&#10;            &#10;            // Reset hands and board&#10;            playerHand = Hand()&#10;            botHand = Hand()&#10;            board = Board()&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    isGameActive = true,&#10;                    gamePhase = GamePhase.FIRST_MINI_ROUND,&#10;                    currentPlayer = game.getFirstPlayer(),&#10;                    gameScore = Pair(game.getP1Points(), game.getP2Points()),&#10;                    gameMessage = &quot;Starting new round...&quot;&#10;                )&#10;            }&#10;            &#10;            // Execute first mini round&#10;            executeFirstMiniRound()&#10;            &#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not found - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error starting round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun executeFirstMiniRound() {&#10;        try {&#10;            currentRound?.firstMiniRound(true) // Choice parameter - can be made configurable&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    gamePhase = GamePhase.PLAYING_CARDS,&#10;                    gameMessage = &quot;First mini round complete. Starting card play...&quot;&#10;                )&#10;            }&#10;            &#10;            // Give initial cards to players&#10;            giveCardsToPlayers()&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error in first mini round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun giveCardsToPlayers() {&#10;        try {&#10;            currentRound?.giveCardsToPlayers()&#10;            &#10;            // Deal cards from deck to hands (3 cards each as per NUM_OF_HAND)&#10;            repeat(3) {&#10;                // Deal to player&#10;                val playerCardData = deck.dealCard()&#10;                if (playerCardData.size &gt;= 2) {&#10;                    playerHand.addCard(playerCardData[0], playerCardData[1])&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data from deck&quot;)&#10;                    }&#10;                    return&#10;                }&#10;                &#10;                // Deal to bot&#10;                val botCardData = deck.dealCard()&#10;                if (botCardData.size &gt;= 2) {&#10;                    botHand.addCard(botCardData[0], botCardData[1])  &#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data from deck&quot;)&#10;                    }&#10;                    return&#10;                }&#10;            }&#10;            &#10;            // Add cards to board (4 cards as per NUM_OF_BOARD)&#10;            repeat(4) {&#10;                val cardData = deck.dealCard()&#10;                if (cardData.size &gt;= 2) {&#10;                    board.addToBoard(cardData[0], cardData[1])&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data for board&quot;)&#10;                    }&#10;                    return&#10;                }&#10;            }&#10;            &#10;            updateGameUI()&#10;            &#10;            // Start player turns&#10;            if (game.getFirstPlayer() == Round.P1) {&#10;                updateUIState {&#10;                    it.copy(&#10;                        isPlayerTurn = true,&#10;                        gameMessage = &quot;Your turn! Play a card or drop one.&quot;&#10;                    )&#10;                }&#10;            } else {&#10;                processBotTurn()&#10;            }&#10;            &#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not available - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error giving cards: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun playCard(cardGui: CardGui) {&#10;        viewModelScope.launch {&#10;            if (!_uiState.value.isPlayerTurn || _uiState.value.gamePhase != GamePhase.PLAYING_CARDS) {&#10;                return@launch&#10;            }&#10;&#10;            try {&#10;                // Find card index in player hand&#10;                val cardIndex = findCardIndexInHand(cardGui, playerHand)&#10;                if (cardIndex == -1) {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Card not found in hand&quot;)&#10;                    }&#10;                    return@launch&#10;                }&#10;&#10;                // Try to play the card (simplified - empty cardsToTake for now)&#10;                val result = playerHand.playCard(cardIndex, intArrayOf(), board)&#10;&#10;                if (result == Hand.STATUS_OK) {&#10;                    updateUIState {&#10;                        it.copy(&#10;                            gameMessage = &quot;Card played successfully!&quot;,&#10;                            isPlayerTurn = false&#10;                        )&#10;                    }&#10;&#10;                    updateGameUI()&#10;                    checkHandsAndContinue()&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Cannot play this card. Try dropping it instead.&quot;)&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error playing card: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun dropCard(cardGui: CardGui) {&#10;        viewModelScope.launch {&#10;            if (!_uiState.value.isPlayerTurn || _uiState.value.gamePhase != GamePhase.PLAYING_CARDS) {&#10;                return@launch&#10;            }&#10;            &#10;            try {&#10;                val cardIndex = findCardIndexInHand(cardGui, playerHand)&#10;                if (cardIndex == -1) {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Card not found in hand&quot;)&#10;                    }&#10;                    return@launch&#10;                }&#10;                &#10;                val result = playerHand.dropCard(cardIndex, board)&#10;                &#10;                if (result == Hand.STATUS_OK) {&#10;                    updateUIState {&#10;                        it.copy(&#10;                            gameMessage = &quot;Card dropped to table&quot;,&#10;                            isPlayerTurn = false&#10;                        )&#10;                    }&#10;                    &#10;                    updateGameUI()&#10;                    checkHandsAndContinue()&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Cannot drop card&quot;)&#10;                    }&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error dropping card: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun processBotTurn() {&#10;        updateUIState {&#10;            it.copy(&#10;                gameMessage = &quot;Bot is thinking...&quot;,&#10;                isPlayerTurn = false&#10;            )&#10;        }&#10;        &#10;        delay(1000) // Add delay for better UX&#10;        &#10;        try {&#10;            val botMove = gameBot.makeMove(botHand, board)&#10;            &#10;            when (botMove) {&#10;                is GameBot.BotMove.PlayCard -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot played a card&quot;)&#10;                    }&#10;                }&#10;                is GameBot.BotMove.DropCard -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot dropped a card&quot;)&#10;                    }&#10;                }&#10;                is GameBot.BotMove.NoMove -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot has no moves&quot;)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            updateGameUI()&#10;            checkHandsAndContinue()&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error in bot turn: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun checkHandsAndContinue() {&#10;        val playerHandSize = playerHand.getHandSize()&#10;        val botHandSize = botHand.getHandSize()&#10;        &#10;        if (playerHandSize == 0 &amp;&amp; botHandSize == 0) {&#10;            // Both hands empty - give new cards or end round&#10;            if (deckHasCards()) {&#10;                updateUIState {&#10;                    it.copy(&#10;                        gamePhase = GamePhase.GIVING_CARDS,&#10;                        gameMessage = &quot;Hands empty, dealing new cards...&quot;&#10;                    )&#10;                }&#10;                delay(1000)&#10;                giveCardsToPlayers()&#10;            } else {&#10;                // Deck is empty - end round&#10;                endRound()&#10;            }&#10;        } else {&#10;            // Continue with next player turn&#10;            val nextPlayerTurn = !_uiState.value.isPlayerTurn&#10;            updateUIState {&#10;                it.copy(isPlayerTurn = nextPlayerTurn)&#10;            }&#10;            &#10;            if (!nextPlayerTurn) {&#10;                // Bot's turn&#10;                delay(500)&#10;                processBotTurn()&#10;            } else {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Your turn!&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun endRound() {&#10;        try {&#10;            currentRound?.countPiles()&#10;            &#10;            val roundP1Points = currentRound?.getP1Points() ?: 0&#10;            val roundP2Points = currentRound?.getP2Points() ?: 0&#10;            &#10;            game.addToP1Points(roundP1Points)&#10;            game.addToP2Points(roundP2Points)&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    gamePhase = GamePhase.ROUND_COMPLETE,&#10;                    roundScore = Pair(roundP1Points, roundP2Points),&#10;                    gameScore = Pair(game.getP1Points(), game.getP2Points()),&#10;                    gameMessage = &quot;Round complete! P1: $roundP1Points, P2: $roundP2Points&quot;&#10;                )&#10;            }&#10;            &#10;            delay(2000)&#10;            &#10;            if (game.isGameOver()) {&#10;                endGame()&#10;            } else {&#10;                // Change first player and start new round&#10;                game.changeFirstPlayer()&#10;                startNewRound()&#10;            }&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error ending round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endGame() {&#10;        val winner = game.getWinner()&#10;        updateUIState {&#10;            it.copy(&#10;                gamePhase = GamePhase.GAME_OVER,&#10;                winner = winner,&#10;                gameMessage = &quot;Game Over! Winner: ${winner ?: &quot;Tie&quot;}&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun findCardIndexInHand(cardGui: CardGui, hand: Hand): Int {&#10;        val handSize = hand.getHandSize()&#10;        for (i in 0 until handSize) {&#10;            val handCard = hand.getCardAsNativeCard(i)&#10;            if (handCard != null &amp;&amp; CardConverter.cardGuiMatchesNativeCard(cardGui, handCard)) {&#10;                return i&#10;            }&#10;        }&#10;        return -1&#10;    }&#10;&#10;    private fun updateGameUI() {&#10;        try {&#10;            val playerCards = playerHand.getAllCards().map { CardConverter.nativeCardToCardGui(it) }&#10;            val botCards = botHand.getAllCards().map { CardConverter.nativeCardToCardGui(it) }&#10;            val tableCards = board.getBoard().map { CardConverter.nativeCardToCardGui(it) }&#10;            &#10;            updateUIState { currentState -&gt;&#10;                currentState.copy(&#10;                    playerHand = playerCards,&#10;                    botHand = botCards,&#10;                    tableCards = tableCards&#10;                )&#10;            }&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not available for UI update - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error updating game UI: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun deckHasCards(): Boolean {&#10;        return try {&#10;            deck.getDeckSize() &gt; 0&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            // If native method fails, assume no cards&#10;            false&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    private inline fun updateUIState(update: (GameUIState) -&gt; GameUIState) {&#10;        _uiState.value = update(_uiState.value)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/shkuba/Board.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/shkuba/Board.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.dinari.shkuba&#10;&#10;class Board {&#10;    // Native pointer to the C++ Board instance&#10;    private var nativeHandle: Long = 0&#10;&#10;    init {&#10;        nativeHandle = nativeCreate()&#10;    }&#10;&#10;    // JNI: Create C++ Board instance&#10;    private external fun nativeCreate(): Long&#10;&#10;    // JNI: Clean up C++ Board instance&#10;    private external fun nativeDestroy(handle: Long)&#10;&#10;    // JNI: Get board size&#10;    external fun getBoardSize(): Int&#10;&#10;    // JNI: Add card to board&#10;    external fun addToBoard(suit: Int, rank: Int)&#10;&#10;    // JNI: Get all cards on board as array of [suit, rank] pairs&#10;    external fun getBoard(): IntArray&#10;&#10;    // Helper function to convert board data to Card objects&#10;    fun getBoardCards(): List&lt;Card&gt; {&#10;        val boardData = getBoard()&#10;        val cards = mutableListOf&lt;Card&gt;()&#10;        for (i in boardData.indices step 2) {&#10;            if (i + 1 &lt; boardData.size) {&#10;                cards.add(Card(boardData[i], boardData[i + 1]))&#10;            }&#10;        }&#10;        return cards&#10;    }&#10;&#10;    protected fun finalize() {&#10;        if (nativeHandle != 0L) {&#10;            nativeDestroy(nativeHandle)&#10;            nativeHandle = 0L&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        init {&#10;            System.loadLibrary(&quot;shkuba&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/shkuba/GameUI.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/shkuba/GameUI.kt" />
              <option name="originalContent" value="package com.dinari.shkuba&#10;&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.interaction.collectIsPressedAsState&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.foundation.horizontalScroll&#10;import com.dinari.shkuba.R&#10;&#10;// Data models&#10;sealed class Suit(val symbol: String) {&#10;    object Spades : Suit(&quot;♠&quot;)&#10;    object Diamonds : Suit(&quot;♦&quot;)&#10;    object Clubs : Suit(&quot;♣&quot;)&#10;    object Hearts : Suit(&quot;♥&quot;)&#10;}&#10;&#10;data class CardGui(val value: String, val suit: Suit) {&#10;    override fun toString(): String = &quot;$value${suit.symbol}&quot;&#10;}&#10;&#10;data class Player(val name: String, val hand: List&lt;CardGui&gt;)&#10;&#10;data class GameState(&#10;    val players: List&lt;Player&gt;,&#10;    val tableCards: List&lt;CardGui&gt;,&#10;    val currentPlayerIndex: Int&#10;)&#10;&#10;// UI Components&#10;@Composable&#10;fun CardView(&#10;    card: CardGui,&#10;    onClick: (() -&gt; Unit)? = null&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .size(70.dp, 100.dp)&#10;            .clickable(enabled = onClick != null) { onClick?.invoke() },&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.White)&#10;                .border(&#10;                    width = 1.dp,&#10;                    color = Color.Gray,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier.padding(4.dp)&#10;            ) {&#10;                Text(&#10;                    text = card.value,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 24.sp&#10;                    ),&#10;                    color = when (card.suit) {&#10;                        is Suit.Hearts, is Suit.Diamonds -&gt; Color(0xFFDC3545)&#10;                        else -&gt; Color(0xFF212529)&#10;                    }&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = card.suit.symbol,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontSize = 20.sp&#10;                    ),&#10;                    color = when (card.suit) {&#10;                        is Suit.Hearts, is Suit.Diamonds -&gt; Color(0xFFDC3545)&#10;                        else -&gt; Color(0xFF212529)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(gameState: GameState, onPlayCard: (CardGui) -&gt; Unit) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0xFFE8F0FE))&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            verticalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                &quot;Shkuba Card Game&quot;,&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 28.sp&#10;                ),&#10;                color = cardTextPrimary(),&#10;                modifier = Modifier.align(Alignment.CenterHorizontally)&#10;            )&#10;&#10;            // Table section&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 16.dp)&#10;                    .shadow(8.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = cardSurface())&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        &quot;Table&quot;,&#10;                        style = MaterialTheme.typography.titleLarge.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = cardTextPrimary()&#10;                    )&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .horizontalScroll(rememberScrollState()),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        gameState.tableCards.forEach { card -&gt;&#10;                            CardView(card)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Player's hand section&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 16.dp)&#10;                    .shadow(8.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = cardSurface())&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        &quot;${gameState.players[gameState.currentPlayerIndex].name}'s Hand&quot;,&#10;                        style = MaterialTheme.typography.titleLarge.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = cardTextPrimary()&#10;                    )&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .horizontalScroll(rememberScrollState()),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        gameState.players[gameState.currentPlayerIndex].hand.forEach { card -&gt;&#10;                            CardView(&#10;                                card = card,&#10;                                onClick = { onPlayCard(card) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainMenu(&#10;    onStartGame: () -&gt; Unit,&#10;    onOptions: () -&gt; Unit,&#10;    onExit: () -&gt; Unit,&#10;    onPvp: () -&gt; Unit,&#10;    startGameLabel: String,&#10;    optionsLabel: String,&#10;    exitLabel: String,&#10;    titleLabel: String&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(&#10;                Brush.verticalGradient(&#10;                    colors = listOf(&#10;                        cardBackground(),&#10;                        Color(0xFFE8F0FE)&#10;                    )&#10;                )&#10;            )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.8f)&#10;                .align(Alignment.Center),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                titleLabel,&#10;                style = MaterialTheme.typography.headlineLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 42.sp,&#10;                    letterSpacing = (-1).sp&#10;                ),&#10;                color = cardTextPrimary()&#10;            )&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            MenuButton(&#10;                text = startGameLabel,&#10;                onClick = onStartGame,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardPrimary(), cardPrimaryLight())&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = optionsLabel,&#10;                onClick = onOptions,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardAccentOrange(), cardAccentOrange().copy(alpha = 0.8f))&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = exitLabel,&#10;                onClick = onExit,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(Color(0xFF6C757D), Color(0xFF495057))&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = stringResource(id = R.string.pvp),&#10;                onClick = onPvp,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardAccentGreen(), cardAccentGreen().copy(alpha = 0.8f))&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MenuButton(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    gradient: Brush&#10;) {&#10;    val interactionSource = remember { MutableInteractionSource() }&#10;    val isPressed by interactionSource.collectIsPressedAsState()&#10;&#10;    val scale = if (isPressed) 0.95f else 1f&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .graphicsLayer(scaleX = scale, scaleY = scale)&#10;            .fillMaxWidth()&#10;            .height(56.dp)&#10;            .background(gradient, RoundedCornerShape(28.dp))&#10;            .clickable(&#10;                interactionSource = interactionSource,&#10;                indication = null,&#10;                onClick = onClick&#10;            )&#10;            .border(&#10;                width = 1.dp,&#10;                color = Color.White.copy(alpha = 0.2f),&#10;                shape = RoundedCornerShape(28.dp)&#10;            )&#10;            .padding(8.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = text,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontWeight = FontWeight.SemiBold,&#10;                letterSpacing = 0.5.sp&#10;            ),&#10;            color = Color.White&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun InGameMenu(&#10;    onMainMenu: () -&gt; Unit,&#10;    onBackToGame: () -&gt; Unit,&#10;    onOptions: () -&gt; Unit,&#10;    mainMenuLabel: String,&#10;    backToGameLabel: String,&#10;    optionsLabel: String,&#10;    titleLabel: String&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0x99000000))&#10;            .clickable(&#10;                interactionSource = remember { MutableInteractionSource() },&#10;                indication = null,&#10;                onClick = onBackToGame&#10;            )&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.9f)&#10;                .align(Alignment.Center)&#10;                .clickable(enabled = false) { },&#10;            shape = RoundedCornerShape(24.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = cardSurface()&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    titleLabel,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontWeight = FontWeight.Bold&#10;                    ),&#10;                    color = cardTextPrimary()&#10;                )&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                MenuButton(&#10;                    text = mainMenuLabel,&#10;                    onClick = onMainMenu,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardPrimary(), cardPrimaryLight())&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                MenuButton(&#10;                    text = optionsLabel,&#10;                    onClick = onOptions,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardAccentOrange(), cardAccentOrange().copy(alpha = 0.8f))&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                MenuButton(&#10;                    text = backToGameLabel,&#10;                    onClick = onBackToGame,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardAccentGreen(), cardAccentGreen().copy(alpha = 0.8f))&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun OptionsScreen(&#10;    isDarkMode: Boolean,&#10;    onToggleTheme: () -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    selectedLanguage: String,&#10;    onLanguageChange: (String) -&gt; Unit,&#10;    languageOptions: List&lt;String&gt;&#10;) {&#10;    val colorScheme = MaterialTheme.colorScheme&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(&#10;                Brush.verticalGradient(&#10;                    colors = listOf(&#10;                        colorScheme.background,&#10;                        colorScheme.surface&#10;                    )&#10;                )&#10;            )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.9f)&#10;                .align(Alignment.Center),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                stringResource(id = R.string.options),&#10;                style = MaterialTheme.typography.headlineLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 36.sp,&#10;                    letterSpacing = (-0.5).sp&#10;                ),&#10;                color = colorScheme.onBackground&#10;            )&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            // Theme Switch&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;                    .shadow(4.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = colorScheme.surface)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        stringResource(id = R.string.dark_mode),&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = colorScheme.onSurface&#10;                    )&#10;                    Switch(&#10;                        checked = isDarkMode,&#10;                        onCheckedChange = { onToggleTheme() },&#10;                        colors = SwitchDefaults.colors(&#10;                            checkedThumbColor = colorScheme.primary,&#10;                            checkedTrackColor = colorScheme.primary.copy(alpha = 0.5f),&#10;                            uncheckedThumbColor = Color.Gray,&#10;                            uncheckedTrackColor = Color.LightGray&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Language Selection&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;                    .shadow(4.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = colorScheme.surface)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        stringResource(id = R.string.language),&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = colorScheme.onSurface&#10;                    )&#10;                    languageOptions.forEach { lang -&gt;&#10;                        val isSelected = lang == selectedLanguage&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(48.dp)&#10;                                .background(&#10;                                    if (isSelected) colorScheme.primary else Color.Transparent,&#10;                                    RoundedCornerShape(24.dp)&#10;                                )&#10;                                .border(&#10;                                    width = 1.dp,&#10;                                    color = if (isSelected) colorScheme.primary else colorScheme.outline,&#10;                                    shape = RoundedCornerShape(24.dp)&#10;                                )&#10;                                .clickable { onLanguageChange(lang) }&#10;                                .padding(horizontal = 16.dp),&#10;                            contentAlignment = Alignment.CenterStart&#10;                        ) {&#10;                            Text(&#10;                                lang,&#10;                                color = if (isSelected) colorScheme.onPrimary else colorScheme.onSurface,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(32.dp))&#10;&#10;            MenuButton(&#10;                text = stringResource(id = R.string.back),&#10;                onClick = onBack,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(colorScheme.secondary, colorScheme.secondary.copy(alpha = 0.8f))&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun cardTextPrimary() = MaterialTheme.colorScheme.onSurface&#10;@Composable&#10;fun cardSurface() = MaterialTheme.colorScheme.surface&#10;@Composable&#10;fun cardBackground() = MaterialTheme.colorScheme.background&#10;@Composable&#10;fun cardPrimary() = MaterialTheme.colorScheme.primary&#10;@Composable&#10;fun cardPrimaryLight() = MaterialTheme.colorScheme.primaryContainer&#10;@Composable&#10;fun cardAccentOrange() = MaterialTheme.colorScheme.secondary&#10;@Composable&#10;fun cardAccentGreen() = MaterialTheme.colorScheme.tertiary&#10;" />
              <option name="updatedContent" value="package com.dinari.shkuba&#13;&#10;&#13;&#10;&#13;&#10;import androidx.compose.foundation.background&#13;&#10;import androidx.compose.foundation.border&#13;&#10;import androidx.compose.foundation.clickable&#13;&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#13;&#10;import androidx.compose.foundation.interaction.collectIsPressedAsState&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.foundation.rememberScrollState&#13;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#13;&#10;import androidx.compose.material3.*&#13;&#10;import androidx.compose.runtime.*&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.graphics.Brush&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.compose.ui.res.stringResource&#13;&#10;import androidx.compose.ui.text.font.FontWeight&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.compose.ui.unit.sp&#13;&#10;import androidx.compose.ui.draw.shadow&#13;&#10;import androidx.compose.ui.graphics.graphicsLayer&#13;&#10;import androidx.compose.foundation.horizontalScroll&#13;&#10;import com.dinari.shkuba.R&#13;&#10;&#13;&#10;// Data models&#13;&#10;sealed class Suit(val symbol: String) {&#13;&#10;    object Spades : Suit(&quot;♠&quot;)&#13;&#10;    object Diamonds : Suit(&quot;♦&quot;)&#13;&#10;    object Clubs : Suit(&quot;♣&quot;)&#13;&#10;    object Hearts : Suit(&quot;♥&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;data class CardGui(val value: String, val suit: Suit) {&#13;&#10;    override fun toString(): String = &quot;$value${suit.symbol}&quot;&#13;&#10;}&#13;&#10;&#13;&#10;data class Player(val name: String, val hand: List&lt;CardGui&gt;)&#13;&#10;&#13;&#10;data class GameState(&#13;&#10;    val players: List&lt;Player&gt;,&#13;&#10;    val tableCards: List&lt;CardGui&gt;,&#13;&#10;    val currentPlayerIndex: Int&#13;&#10;)&#13;&#10;&#13;&#10;// UI Components&#13;&#10;@Composable&#13;&#10;fun CardView(&#13;&#10;    card: CardGui,&#13;&#10;    onClick: (() -&gt; Unit)? = null&#13;&#10;) {&#13;&#10;    Card(&#13;&#10;        modifier = Modifier&#13;&#10;            .size(70.dp, 100.dp)&#13;&#10;            .clickable(enabled = onClick != null) { onClick?.invoke() },&#13;&#10;        shape = RoundedCornerShape(12.dp),&#13;&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#13;&#10;    ) {&#13;&#10;        Box(&#13;&#10;            modifier = Modifier&#13;&#10;                .fillMaxSize()&#13;&#10;                .background(Color.White)&#13;&#10;                .border(&#13;&#10;                    width = 1.dp,&#13;&#10;                    color = Color.Gray,&#13;&#10;                    shape = RoundedCornerShape(12.dp)&#13;&#10;                ),&#13;&#10;            contentAlignment = Alignment.Center&#13;&#10;        ) {&#13;&#10;            Column(&#13;&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                verticalArrangement = Arrangement.Center,&#13;&#10;                modifier = Modifier.padding(4.dp)&#13;&#10;            ) {&#13;&#10;                Text(&#13;&#10;                    text = card.value,&#13;&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#13;&#10;                        fontWeight = FontWeight.Bold,&#13;&#10;                        fontSize = 24.sp&#13;&#10;                    ),&#13;&#10;                    color = when (card.suit) {&#13;&#10;                        is Suit.Hearts, is Suit.Diamonds -&gt; Color(0xFFDC3545)&#13;&#10;                        else -&gt; Color(0xFF212529)&#13;&#10;                    }&#13;&#10;                )&#13;&#10;                Spacer(modifier = Modifier.height(4.dp))&#13;&#10;                Text(&#13;&#10;                    text = card.suit.symbol,&#13;&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#13;&#10;                        fontSize = 20.sp&#13;&#10;                    ),&#13;&#10;                    color = when (card.suit) {&#13;&#10;                        is Suit.Hearts, is Suit.Diamonds -&gt; Color(0xFFDC3545)&#13;&#10;                        else -&gt; Color(0xFF212529)&#13;&#10;                    }&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun GameScreen(gameState: GameState, onPlayCard: (CardGui) -&gt; Unit, onTableCardClick: (CardGui) -&gt; Unit) {&#13;&#10;    Box(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize()&#13;&#10;            .background(Color(0xFFE8F0FE))&#13;&#10;            .padding(16.dp)&#13;&#10;    ) {&#13;&#10;        Column(&#13;&#10;            modifier = Modifier.fillMaxSize(),&#13;&#10;            verticalArrangement = Arrangement.SpaceBetween&#13;&#10;        ) {&#13;&#10;            Text(&#13;&#10;                &quot;Shkuba Card Game&quot;,&#13;&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#13;&#10;                    fontWeight = FontWeight.Bold,&#13;&#10;                    fontSize = 28.sp&#13;&#10;                ),&#13;&#10;                color = cardTextPrimary(),&#13;&#10;                modifier = Modifier.align(Alignment.CenterHorizontally)&#13;&#10;            )&#13;&#10;&#13;&#10;            // Table section&#13;&#10;            Card(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .padding(vertical = 16.dp)&#13;&#10;                    .shadow(8.dp, RoundedCornerShape(16.dp)),&#13;&#10;                shape = RoundedCornerShape(16.dp),&#13;&#10;                colors = CardDefaults.cardColors(containerColor = cardSurface())&#13;&#10;            ) {&#13;&#10;                Column(&#13;&#10;                    modifier = Modifier.padding(16.dp),&#13;&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#13;&#10;                ) {&#13;&#10;                    Text(&#13;&#10;                        &quot;Table&quot;,&#13;&#10;                        style = MaterialTheme.typography.titleLarge.copy(&#13;&#10;                            fontWeight = FontWeight.SemiBold&#13;&#10;                        ),&#13;&#10;                        color = cardTextPrimary()&#13;&#10;                    )&#13;&#10;                    Row(&#13;&#10;                        modifier = Modifier&#13;&#10;                            .fillMaxWidth()&#13;&#10;                            .horizontalScroll(rememberScrollState()),&#13;&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;                    ) {&#13;&#10;                        gameState.tableCards.forEach { card -&gt;&#13;&#10;                            CardView(card = card, onClick = { onTableCardClick(card) })&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            // Player's hand section&#13;&#10;            Card(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .padding(vertical = 16.dp)&#13;&#10;                    .shadow(8.dp, RoundedCornerShape(16.dp)),&#13;&#10;                shape = RoundedCornerShape(16.dp),&#13;&#10;                colors = CardDefaults.cardColors(containerColor = cardSurface())&#13;&#10;            ) {&#13;&#10;                Column(&#13;&#10;                    modifier = Modifier.padding(16.dp),&#13;&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#13;&#10;                ) {&#13;&#10;                    Text(&#13;&#10;                        &quot;Your Hand&quot;,&#13;&#10;                        style = MaterialTheme.typography.titleLarge.copy(&#13;&#10;                            fontWeight = FontWeight.SemiBold&#13;&#10;                        ),&#13;&#10;                        color = cardTextPrimary()&#13;&#10;                    )&#13;&#10;                    Row(&#13;&#10;                        modifier = Modifier&#13;&#10;                            .fillMaxWidth()&#13;&#10;                            .horizontalScroll(rememberScrollState()),&#13;&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;                    ) {&#13;&#10;                        gameState.players.first().hand.forEach { card -&gt;&#13;&#10;                            CardView(card = card, onClick = { onPlayCard(card) })&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun MainMenu(&#13;&#10;    onStartGame: () -&gt; Unit,&#13;&#10;    onOptions: () -&gt; Unit,&#13;&#10;    onExit: () -&gt; Unit,&#13;&#10;    onPvp: () -&gt; Unit,&#13;&#10;    startGameLabel: String,&#13;&#10;    optionsLabel: String,&#13;&#10;    exitLabel: String,&#13;&#10;    titleLabel: String&#13;&#10;) {&#13;&#10;    Box(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize()&#13;&#10;            .background(&#13;&#10;                Brush.verticalGradient(&#13;&#10;                    colors = listOf(&#13;&#10;                        cardBackground(),&#13;&#10;                        Color(0xFFE8F0FE)&#13;&#10;                    )&#13;&#10;                )&#13;&#10;            )&#13;&#10;    ) {&#13;&#10;        Column(&#13;&#10;            modifier = Modifier&#13;&#10;                .fillMaxWidth(0.8f)&#13;&#10;                .align(Alignment.Center),&#13;&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;            verticalArrangement = Arrangement.Center&#13;&#10;        ) {&#13;&#10;            Text(&#13;&#10;                titleLabel,&#13;&#10;                style = MaterialTheme.typography.headlineLarge.copy(&#13;&#10;                    fontWeight = FontWeight.Bold,&#13;&#10;                    fontSize = 42.sp,&#13;&#10;                    letterSpacing = (-1).sp&#13;&#10;                ),&#13;&#10;                color = cardTextPrimary()&#13;&#10;            )&#13;&#10;            Spacer(modifier = Modifier.height(48.dp))&#13;&#10;&#13;&#10;            MenuButton(&#13;&#10;                text = startGameLabel,&#13;&#10;                onClick = onStartGame,&#13;&#10;                gradient = Brush.horizontalGradient(&#13;&#10;                    colors = listOf(cardPrimary(), cardPrimaryLight())&#13;&#10;                )&#13;&#10;            )&#13;&#10;            Spacer(modifier = Modifier.height(16.dp))&#13;&#10;            MenuButton(&#13;&#10;                text = optionsLabel,&#13;&#10;                onClick = onOptions,&#13;&#10;                gradient = Brush.horizontalGradient(&#13;&#10;                    colors = listOf(cardAccentOrange(), cardAccentOrange().copy(alpha = 0.8f))&#13;&#10;                )&#13;&#10;            )&#13;&#10;            Spacer(modifier = Modifier.height(16.dp))&#13;&#10;            MenuButton(&#13;&#10;                text = exitLabel,&#13;&#10;                onClick = onExit,&#13;&#10;                gradient = Brush.horizontalGradient(&#13;&#10;                    colors = listOf(Color(0xFF6C757D), Color(0xFF495057))&#13;&#10;                )&#13;&#10;            )&#13;&#10;            Spacer(modifier = Modifier.height(16.dp))&#13;&#10;            MenuButton(&#13;&#10;                text = stringResource(id = R.string.pvp),&#13;&#10;                onClick = onPvp,&#13;&#10;                gradient = Brush.horizontalGradient(&#13;&#10;                    colors = listOf(cardAccentGreen(), cardAccentGreen().copy(alpha = 0.8f))&#13;&#10;                )&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun MenuButton(&#13;&#10;    text: String,&#13;&#10;    onClick: () -&gt; Unit,&#13;&#10;    gradient: Brush&#13;&#10;) {&#13;&#10;    val interactionSource = remember { MutableInteractionSource() }&#13;&#10;    val isPressed by interactionSource.collectIsPressedAsState()&#13;&#10;&#13;&#10;    val scale = if (isPressed) 0.95f else 1f&#13;&#10;&#13;&#10;    Box(&#13;&#10;        modifier = Modifier&#13;&#10;            .graphicsLayer(scaleX = scale, scaleY = scale)&#13;&#10;            .fillMaxWidth()&#13;&#10;            .height(56.dp)&#13;&#10;            .background(gradient, RoundedCornerShape(28.dp))&#13;&#10;            .clickable(&#13;&#10;                interactionSource = interactionSource,&#13;&#10;                indication = null,&#13;&#10;                onClick = onClick&#13;&#10;            )&#13;&#10;            .border(&#13;&#10;                width = 1.dp,&#13;&#10;                color = Color.White.copy(alpha = 0.2f),&#13;&#10;                shape = RoundedCornerShape(28.dp)&#13;&#10;            )&#13;&#10;            .padding(8.dp),&#13;&#10;        contentAlignment = Alignment.Center&#13;&#10;    ) {&#13;&#10;        Text(&#13;&#10;            text = text,&#13;&#10;            style = MaterialTheme.typography.titleMedium.copy(&#13;&#10;                fontWeight = FontWeight.SemiBold,&#13;&#10;                letterSpacing = 0.5.sp&#13;&#10;            ),&#13;&#10;            color = Color.White&#13;&#10;        )&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun InGameMenu(&#13;&#10;    onMainMenu: () -&gt; Unit,&#13;&#10;    onBackToGame: () -&gt; Unit,&#13;&#10;    onOptions: () -&gt; Unit,&#13;&#10;    mainMenuLabel: String,&#13;&#10;    backToGameLabel: String,&#13;&#10;    optionsLabel: String,&#13;&#10;    titleLabel: String&#13;&#10;) {&#13;&#10;    Box(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize()&#13;&#10;            .background(Color(0x99000000))&#13;&#10;            .clickable(&#13;&#10;                interactionSource = remember { MutableInteractionSource() },&#13;&#10;                indication = null,&#13;&#10;                onClick = onBackToGame&#13;&#10;            )&#13;&#10;    ) {&#13;&#10;        Card(&#13;&#10;            modifier = Modifier&#13;&#10;                .fillMaxWidth(0.9f)&#13;&#10;                .align(Alignment.Center)&#13;&#10;                .clickable(enabled = false) { },&#13;&#10;            shape = RoundedCornerShape(24.dp),&#13;&#10;            colors = CardDefaults.cardColors(&#13;&#10;                containerColor = cardSurface()&#13;&#10;            )&#13;&#10;        ) {&#13;&#10;            Column(&#13;&#10;                modifier = Modifier.padding(24.dp),&#13;&#10;                horizontalAlignment = Alignment.CenterHorizontally&#13;&#10;            ) {&#13;&#10;                Text(&#13;&#10;                    titleLabel,&#13;&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#13;&#10;                        fontWeight = FontWeight.Bold&#13;&#10;                    ),&#13;&#10;                    color = cardTextPrimary()&#13;&#10;                )&#13;&#10;                Spacer(modifier = Modifier.height(32.dp))&#13;&#10;&#13;&#10;                MenuButton(&#13;&#10;                    text = mainMenuLabel,&#13;&#10;                    onClick = onMainMenu,&#13;&#10;                    gradient = Brush.horizontalGradient(&#13;&#10;                        colors = listOf(cardPrimary(), cardPrimaryLight())&#13;&#10;                    )&#13;&#10;                )&#13;&#10;                Spacer(modifier = Modifier.height(16.dp))&#13;&#10;                MenuButton(&#13;&#10;                    text = optionsLabel,&#13;&#10;                    onClick = onOptions,&#13;&#10;                    gradient = Brush.horizontalGradient(&#13;&#10;                        colors = listOf(cardAccentOrange(), cardAccentOrange().copy(alpha = 0.8f))&#13;&#10;                    )&#13;&#10;                )&#13;&#10;                Spacer(modifier = Modifier.height(16.dp))&#13;&#10;                MenuButton(&#13;&#10;                    text = backToGameLabel,&#13;&#10;                    onClick = onBackToGame,&#13;&#10;                    gradient = Brush.horizontalGradient(&#13;&#10;                        colors = listOf(cardAccentGreen(), cardAccentGreen().copy(alpha = 0.8f))&#13;&#10;                    )&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun OptionsScreen(&#13;&#10;    isDarkMode: Boolean,&#13;&#10;    onToggleTheme: () -&gt; Unit,&#13;&#10;    onBack: () -&gt; Unit,&#13;&#10;    selectedLanguage: String,&#13;&#10;    onLanguageChange: (String) -&gt; Unit,&#13;&#10;    languageOptions: List&lt;String&gt;&#13;&#10;) {&#13;&#10;    val colorScheme = MaterialTheme.colorScheme&#13;&#10;    Box(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize()&#13;&#10;            .background(&#13;&#10;                Brush.verticalGradient(&#13;&#10;                    colors = listOf(&#13;&#10;                        colorScheme.background,&#13;&#10;                        colorScheme.surface&#13;&#10;                    )&#13;&#10;                )&#13;&#10;            )&#13;&#10;    ) {&#13;&#10;        Column(&#13;&#10;            modifier = Modifier&#13;&#10;                .fillMaxWidth(0.9f)&#13;&#10;                .align(Alignment.Center),&#13;&#10;            horizontalAlignment = Alignment.CenterHorizontally&#13;&#10;        ) {&#13;&#10;            Text(&#13;&#10;                stringResource(id = R.string.options),&#13;&#10;                style = MaterialTheme.typography.headlineLarge.copy(&#13;&#10;                    fontWeight = FontWeight.Bold,&#13;&#10;                    fontSize = 36.sp,&#13;&#10;                    letterSpacing = (-0.5).sp&#13;&#10;                ),&#13;&#10;                color = colorScheme.onBackground&#13;&#10;            )&#13;&#10;            Spacer(modifier = Modifier.height(48.dp))&#13;&#10;&#13;&#10;            // Theme Switch&#13;&#10;            Card(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .padding(vertical = 8.dp)&#13;&#10;                    .shadow(4.dp, RoundedCornerShape(16.dp)),&#13;&#10;                shape = RoundedCornerShape(16.dp),&#13;&#10;                colors = CardDefaults.cardColors(containerColor = colorScheme.surface)&#13;&#10;            ) {&#13;&#10;                Row(&#13;&#10;                    modifier = Modifier&#13;&#10;                        .fillMaxWidth()&#13;&#10;                        .padding(16.dp),&#13;&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#13;&#10;                    verticalAlignment = Alignment.CenterVertically&#13;&#10;                ) {&#13;&#10;                    Text(&#13;&#10;                        stringResource(id = R.string.dark_mode),&#13;&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#13;&#10;                            fontWeight = FontWeight.SemiBold&#13;&#10;                        ),&#13;&#10;                        color = colorScheme.onSurface&#13;&#10;                    )&#13;&#10;                    Switch(&#13;&#10;                        checked = isDarkMode,&#13;&#10;                        onCheckedChange = { onToggleTheme() },&#13;&#10;                        colors = SwitchDefaults.colors(&#13;&#10;                            checkedThumbColor = colorScheme.primary,&#13;&#10;                            checkedTrackColor = colorScheme.primary.copy(alpha = 0.5f),&#13;&#10;                            uncheckedThumbColor = Color.Gray,&#13;&#10;                            uncheckedTrackColor = Color.LightGray&#13;&#10;                        )&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            Spacer(modifier = Modifier.height(24.dp))&#13;&#10;&#13;&#10;            // Language Selection&#13;&#10;            Card(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .padding(vertical = 8.dp)&#13;&#10;                    .shadow(4.dp, RoundedCornerShape(16.dp)),&#13;&#10;                shape = RoundedCornerShape(16.dp),&#13;&#10;                colors = CardDefaults.cardColors(containerColor = colorScheme.surface)&#13;&#10;            ) {&#13;&#10;                Column(&#13;&#10;                    modifier = Modifier&#13;&#10;                        .fillMaxWidth()&#13;&#10;                        .padding(16.dp),&#13;&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#13;&#10;                ) {&#13;&#10;                    Text(&#13;&#10;                        stringResource(id = R.string.language),&#13;&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#13;&#10;                            fontWeight = FontWeight.SemiBold&#13;&#10;                        ),&#13;&#10;                        color = colorScheme.onSurface&#13;&#10;                    )&#13;&#10;                    languageOptions.forEach { lang -&gt;&#13;&#10;                        val isSelected = lang == selectedLanguage&#13;&#10;                        Box(&#13;&#10;                            modifier = Modifier&#13;&#10;                                .fillMaxWidth()&#13;&#10;                                .height(48.dp)&#13;&#10;                                .background(&#13;&#10;                                    if (isSelected) colorScheme.primary else Color.Transparent,&#13;&#10;                                    RoundedCornerShape(24.dp)&#13;&#10;                                )&#13;&#10;                                .border(&#13;&#10;                                    width = 1.dp,&#13;&#10;                                    color = if (isSelected) colorScheme.primary else colorScheme.outline,&#13;&#10;                                    shape = RoundedCornerShape(24.dp)&#13;&#10;                                )&#13;&#10;                                .clickable { onLanguageChange(lang) }&#13;&#10;                                .padding(horizontal = 16.dp),&#13;&#10;                            contentAlignment = Alignment.CenterStart&#13;&#10;                        ) {&#13;&#10;                            Text(&#13;&#10;                                lang,&#13;&#10;                                color = if (isSelected) colorScheme.onPrimary else colorScheme.onSurface,&#13;&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#13;&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal&#13;&#10;                                )&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            Spacer(modifier = Modifier.height(32.dp))&#13;&#10;&#13;&#10;            MenuButton(&#13;&#10;                text = stringResource(id = R.string.back),&#13;&#10;                onClick = onBack,&#13;&#10;                gradient = Brush.horizontalGradient(&#13;&#10;                    colors = listOf(colorScheme.secondary, colorScheme.secondary.copy(alpha = 0.8f))&#13;&#10;                )&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun cardTextPrimary() = MaterialTheme.colorScheme.onSurface&#13;&#10;@Composable&#13;&#10;fun cardSurface() = MaterialTheme.colorScheme.surface&#13;&#10;@Composable&#13;&#10;fun cardBackground() = MaterialTheme.colorScheme.background&#13;&#10;@Composable&#13;&#10;fun cardPrimary() = MaterialTheme.colorScheme.primary&#13;&#10;@Composable&#13;&#10;fun cardPrimaryLight() = MaterialTheme.colorScheme.primaryContainer&#13;&#10;@Composable&#13;&#10;fun cardAccentOrange() = MaterialTheme.colorScheme.secondary&#13;&#10;@Composable&#13;&#10;fun cardAccentGreen() = MaterialTheme.colorScheme.tertiary" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}&#10;&#10;allprojects {&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;}&#10;&#10;allprojects {&#10;    // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>