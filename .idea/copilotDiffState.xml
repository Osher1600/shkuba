<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/dinari/shkuba/GameUI.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/dinari/shkuba/GameUI.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/dinari/shkuba/GameViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/dinari/shkuba/GameViewModel.kt" />
              <option name="originalContent" value="package com.dinari.shkuba&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.delay&#10;&#10;data class GameUIState(&#10;    val isGameActive: Boolean = false,&#10;    val currentPlayer: Int = Round.P1,&#10;    val playerHand: List&lt;CardGui&gt; = emptyList(),&#10;    val botHand: List&lt;CardGui&gt; = emptyList(),&#10;    val tableCards: List&lt;CardGui&gt; = emptyList(),&#10;    val gameScore: Pair&lt;Int, Int&gt; = Pair(0, 0), // (P1, P2)&#10;    val roundScore: Pair&lt;Int, Int&gt; = Pair(0, 0), // (P1, P2)&#10;    val gameMessage: String = &quot;&quot;,&#10;    val isPlayerTurn: Boolean = true,&#10;    val gamePhase: GamePhase = GamePhase.NOT_STARTED,&#10;    val winner: String? = null&#10;)&#10;&#10;enum class GamePhase {&#10;    NOT_STARTED,&#10;    FIRST_MINI_ROUND,&#10;    PLAYING_CARDS,&#10;    GIVING_CARDS,&#10;    ROUND_COMPLETE,&#10;    GAME_OVER&#10;}&#10;&#10;class GameViewModel : ViewModel() {&#10;    private val _uiState = MutableStateFlow(GameUIState())&#10;    val uiState: StateFlow&lt;GameUIState&gt; = _uiState.asStateFlow()&#10;&#10;    private var game: Game = Game()&#10;    private var currentRound: Round? = null&#10;    private var deck: Deck = Deck()&#10;    private var playerHand: Hand = Hand()&#10;    private var botHand: Hand = Hand()&#10;    private var board: Board = Board()&#10;    private var gameBot: GameBot = GameBot()&#10;&#10;    fun startNewGame() {&#10;        viewModelScope.launch {&#10;            // Reset game state&#10;            game = Game()&#10;            startNewRound()&#10;        }&#10;    }&#10;&#10;    private suspend fun startNewRound() {&#10;        try {&#10;            // Check if native library is loaded&#10;            if (!com.shkuba.MainActivity.isLibraryLoaded()) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error: Native library not loaded. Cannot start game.&quot;)&#10;                }&#10;                return&#10;            }&#10;            &#10;            // Create new round with current first player&#10;            currentRound = game.createNewRound()&#10;            &#10;            // Create new deck and shuffle&#10;            deck = Deck()&#10;            &#10;            // Reset hands and board&#10;            playerHand = Hand()&#10;            botHand = Hand()&#10;            board = Board()&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    isGameActive = true,&#10;                    gamePhase = GamePhase.FIRST_MINI_ROUND,&#10;                    currentPlayer = game.getFirstPlayer(),&#10;                    gameScore = Pair(game.getP1Points(), game.getP2Points()),&#10;                    gameMessage = &quot;Starting new round...&quot;&#10;                )&#10;            }&#10;            &#10;            // Execute first mini round&#10;            executeFirstMiniRound()&#10;            &#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not found - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error starting round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun executeFirstMiniRound() {&#10;        try {&#10;            currentRound?.firstMiniRound(true) // Choice parameter - can be made configurable&#10;&#10;            updateUIState {&#10;                it.copy(&#10;                    gamePhase = GamePhase.PLAYING_CARDS,&#10;                    gameMessage = &quot;First mini round complete. Starting card play...&quot;&#10;                )&#10;            }&#10;&#10;            // Give initial cards to players&#10;            giveCardsToPlayers()&#10;&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error in first mini round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun giveCardsToPlayers() {&#10;        try {&#10;            currentRound?.giveCardsToPlayers()&#10;            &#10;            // Deal cards from deck to hands (3 cards each as per NUM_OF_HAND)&#10;            repeat(3) {&#10;                // Deal to player&#10;                val playerCardData = deck.dealCard()&#10;                if (playerCardData.size &gt;= 2) {&#10;                    playerHand.addCard(playerCardData[0], playerCardData[1])&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data from deck&quot;)&#10;                    }&#10;                    return&#10;                }&#10;                &#10;                // Deal to bot&#10;                val botCardData = deck.dealCard()&#10;                if (botCardData.size &gt;= 2) {&#10;                    botHand.addCard(botCardData[0], botCardData[1])  &#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data from deck&quot;)&#10;                    }&#10;                    return&#10;                }&#10;            }&#10;            &#10;            // Add cards to board (4 cards as per NUM_OF_BOARD)&#10;            repeat(4) {&#10;                val cardData = deck.dealCard()&#10;                if (cardData.size &gt;= 2) {&#10;                    board.addToBoard(cardData[0], cardData[1])&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data for board&quot;)&#10;                    }&#10;                    return&#10;                }&#10;            }&#10;            &#10;            updateGameUI()&#10;            &#10;            // Start player turns&#10;            if (game.getFirstPlayer() == Round.P1) {&#10;                updateUIState {&#10;                    it.copy(&#10;                        isPlayerTurn = true,&#10;                        gameMessage = &quot;Your turn! Play a card or drop one.&quot;&#10;                    )&#10;                }&#10;            } else {&#10;                processBotTurn()&#10;            }&#10;            &#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not available - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error giving cards: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun playCard(cardGui: CardGui, selectedTableCards: List&lt;CardGui&gt;) {&#10;        viewModelScope.launch {&#10;            if (!_uiState.value.isPlayerTurn || _uiState.value.gamePhase != GamePhase.PLAYING_CARDS) {&#10;                return@launch&#10;            }&#10;&#10;            try {&#10;                // Find card index in player hand&#10;                val cardIndex = findCardIndexInHand(cardGui, playerHand)&#10;                if (cardIndex == -1) {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Card not found in hand&quot;)&#10;                    }&#10;                    return@launch&#10;                }&#10;&#10;                // Convert selected table cards to indices&#10;                val tableCardIndices = selectedTableCards.mapNotNull { tableCard -&gt;&#10;                    board.getBoard().indexOfFirst { CardConverter.cardGuiMatchesNativeCard(tableCard, it) }.takeIf { it &gt;= 0 }&#10;                }&#10;&#10;                // Try to play the card with selected table cards&#10;                val result = playerHand.playCard(cardIndex, tableCardIndices.toIntArray(), board)&#10;&#10;                if (result == Hand.STATUS_OK)&#10;                {&#10;&#10;                    updateUIState {&#10;                        it.copy(&#10;                            gameMessage = &quot;Card played successfully!&quot;,&#10;                            isPlayerTurn = false&#10;                        )&#10;                    }&#10;                    updateGameUI()&#10;                    checkHandsAndContinue()&#10;                }&#10;                else if (result == Hand.STATUS_ERROR_NOT_FIT)&#10;                {&#10;                    playerHand.dropCard(cardIndex, board);&#10;                    updateGameUI()&#10;                    checkHandsAndContinue()&#10;                }&#10;                else&#10;                {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Cannot play this card.&quot;)&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error playing card: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun canDropCard(selectedHandCard: CardGui?, selectedTableCards: List&lt;CardGui&gt;): Boolean {&#10;        return if (selectedHandCard == null) {&#10;            false&#10;        } else {&#10;            selectedTableCards.isEmpty() || board.getBoard().none { tableCard -&gt;&#10;                CardConverter.cardGuiMatchesNativeCard(selectedHandCard, tableCard)&#10;            }&#10;        }&#10;    }&#10;    private suspend fun processBotTurn() {&#10;        updateUIState {&#10;            it.copy(&#10;                gameMessage = &quot;Bot is thinking...&quot;,&#10;                isPlayerTurn = false&#10;            )&#10;        }&#10;        &#10;        delay(1000) // Add delay for better UX&#10;        &#10;        try {&#10;            val botMove = gameBot.makeMove(botHand, board)&#10;            &#10;            when (botMove) {&#10;                is GameBot.BotMove.PlayCard -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot played a card&quot;)&#10;                    }&#10;                }&#10;                is GameBot.BotMove.DropCard -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot dropped a card&quot;)&#10;                    }&#10;                }&#10;                is GameBot.BotMove.NoMove -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot has no moves&quot;)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            updateGameUI()&#10;            checkHandsAndContinue()&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error in bot turn: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun checkHandsAndContinue() {&#10;        val playerHandSize = playerHand.getHandSize()&#10;        val botHandSize = botHand.getHandSize()&#10;        &#10;        if (playerHandSize == 0 &amp;&amp; botHandSize == 0) {&#10;            // Both hands empty - give new cards or end round&#10;            if (deckHasCards()) {&#10;                updateUIState {&#10;                    it.copy(&#10;                        gamePhase = GamePhase.GIVING_CARDS,&#10;                        gameMessage = &quot;Hands empty, dealing new cards...&quot;&#10;                    )&#10;                }&#10;                delay(1000)&#10;                giveCardsToPlayers()&#10;            } else {&#10;                // Deck is empty - end round&#10;                endRound()&#10;            }&#10;        } else {&#10;            // Continue with next player turn&#10;            val nextPlayerTurn = !_uiState.value.isPlayerTurn&#10;            updateUIState {&#10;                it.copy(isPlayerTurn = nextPlayerTurn)&#10;            }&#10;            &#10;            if (!nextPlayerTurn) {&#10;                // Bot's turn&#10;                delay(500)&#10;                processBotTurn()&#10;            } else {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Your turn!&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun endRound() {&#10;        try {&#10;            currentRound?.countPiles()&#10;            &#10;            val roundP1Points = currentRound?.getP1Points() ?: 0&#10;            val roundP2Points = currentRound?.getP2Points() ?: 0&#10;            &#10;            game.addToP1Points(roundP1Points)&#10;            game.addToP2Points(roundP2Points)&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    gamePhase = GamePhase.ROUND_COMPLETE,&#10;                    roundScore = Pair(roundP1Points, roundP2Points),&#10;                    gameScore = Pair(game.getP1Points(), game.getP2Points()),&#10;                    gameMessage = &quot;Round complete! P1: $roundP1Points, P2: $roundP2Points&quot;&#10;                )&#10;            }&#10;            &#10;            delay(2000)&#10;            &#10;            if (game.isGameOver()) {&#10;                endGame()&#10;            } else {&#10;                // Change first player and start new round&#10;                game.changeFirstPlayer()&#10;                startNewRound()&#10;            }&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error ending round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endGame() {&#10;        val winner = game.getWinner()&#10;        updateUIState {&#10;            it.copy(&#10;                gamePhase = GamePhase.GAME_OVER,&#10;                winner = winner,&#10;                gameMessage = &quot;Game Over! Winner: ${winner ?: &quot;Tie&quot;}&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun findCardIndexInHand(cardGui: CardGui, hand: Hand): Int {&#10;        val handSize = hand.getHandSize()&#10;        for (i in 0 until handSize) {&#10;            val handCard = hand.getCardAsNativeCard(i)&#10;            if (handCard != null &amp;&amp; CardConverter.cardGuiMatchesNativeCard(cardGui, handCard)) {&#10;                return i&#10;            }&#10;        }&#10;        return -1&#10;    }&#10;&#10;    private fun updateGameUI() {&#10;        try {&#10;            val playerCards = playerHand.getAllCards().map { CardConverter.nativeCardToCardGui(it) }&#10;            val botCards = botHand.getAllCards().map { CardConverter.nativeCardToCardGui(it) }&#10;            val tableCards = board.getBoard().map { CardConverter.nativeCardToCardGui(it) }&#10;            &#10;            updateUIState { currentState -&gt;&#10;                currentState.copy(&#10;                    playerHand = playerCards,&#10;                    botHand = botCards,&#10;                    tableCards = tableCards&#10;                )&#10;            }&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not available for UI update - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error updating game UI: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun deckHasCards(): Boolean {&#10;        return try {&#10;            deck.getDeckSize() &gt; 0&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            // If native method fails, assume no cards&#10;            false&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    private inline fun updateUIState(update: (GameUIState) -&gt; GameUIState) {&#10;        _uiState.value = update(_uiState.value)&#10;    }&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.dinari.shkuba&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.delay&#10;&#10;data class GameUIState(&#10;    val isGameActive: Boolean = false,&#10;    val currentPlayer: Int = Round.P1,&#10;    val playerHand: List&lt;CardGui&gt; = emptyList(),&#10;    val botHand: List&lt;CardGui&gt; = emptyList(),&#10;    val tableCards: List&lt;CardGui&gt; = emptyList(),&#10;    val gameScore: Pair&lt;Int, Int&gt; = Pair(0, 0), // (P1, P2)&#10;    val roundScore: Pair&lt;Int, Int&gt; = Pair(0, 0), // (P1, P2)&#10;    val gameMessage: String = &quot;&quot;,&#10;    val isPlayerTurn: Boolean = true,&#10;    val gamePhase: GamePhase = GamePhase.NOT_STARTED,&#10;    val winner: String? = null,&#10;    val startCard: CardGui? = null, // The card that can be chosen at round start&#10;    val isChoosingStartCard: Boolean = false // True if user/bot is choosing start card&#10;)&#10;&#10;enum class GamePhase {&#10;    NOT_STARTED,&#10;    FIRST_MINI_ROUND,&#10;    PLAYING_CARDS,&#10;    GIVING_CARDS,&#10;    ROUND_COMPLETE,&#10;    GAME_OVER&#10;}&#10;&#10;class GameViewModel : ViewModel() {&#10;    private val _uiState = MutableStateFlow(GameUIState())&#10;    val uiState: StateFlow&lt;GameUIState&gt; = _uiState.asStateFlow()&#10;&#10;    private var game: Game = Game()&#10;    private var currentRound: Round? = null&#10;    private var deck: Deck = Deck()&#10;    private var playerHand: Hand = Hand()&#10;    private var botHand: Hand = Hand()&#10;    private var board: Board = Board()&#10;    private var gameBot: GameBot = GameBot()&#10;&#10;    fun startNewGame() {&#10;        viewModelScope.launch {&#10;            // Reset game state&#10;            game = Game()&#10;            startNewRound()&#10;        }&#10;    }&#10;&#10;    private suspend fun startNewRound() {&#10;        try {&#10;            // Check if native library is loaded&#10;            if (!com.shkuba.MainActivity.isLibraryLoaded()) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error: Native library not loaded. Cannot start game.&quot;)&#10;                }&#10;                return&#10;            }&#10;            &#10;            // Create new round with current first player&#10;            currentRound = game.createNewRound()&#10;            &#10;            // Create new deck and shuffle&#10;            deck = Deck()&#10;            &#10;            // Reset hands and board&#10;            playerHand = Hand()&#10;            botHand = Hand()&#10;            board = Board()&#10;&#10;            // Get the start card from the round&#10;            val startCardNative = currentRound?.getStartCard()&#10;            val startCardGui = startCardNative?.let { CardConverter.nativeCardToCardGui(it) }&#10;&#10;            updateUIState {&#10;                it.copy(&#10;                    isGameActive = true,&#10;                    gamePhase = GamePhase.FIRST_MINI_ROUND,&#10;                    currentPlayer = game.getFirstPlayer(),&#10;                    gameScore = Pair(game.getP1Points(), game.getP2Points()),&#10;                    gameMessage = &quot;Choose if you want to take the start card as one of your hand cards.&quot;,&#10;                    startCard = startCardGui,&#10;                    isChoosingStartCard = true&#10;                )&#10;            }&#10;&#10;            // Prompt user or bot to choose start card&#10;            if (game.getFirstPlayer() == Round.P1) {&#10;                // Wait for user input via UI (call onUserChooseStartCard from UI)&#10;            } else {&#10;                // Bot chooses automatically&#10;                handleBotChooseStartCard()&#10;            }&#10;&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not found - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error starting round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onUserChooseStartCard(takeStartCard: Boolean) {&#10;        viewModelScope.launch {&#10;            updateUIState {&#10;                it.copy(isChoosingStartCard = false)&#10;            }&#10;            executeFirstMiniRound(takeStartCard)&#10;        }&#10;    }&#10;&#10;    private suspend fun handleBotChooseStartCard() {&#10;        // Simple bot logic: randomly decide or always take/not take&#10;        val takeStartCard = gameBot.shouldTakeStartCard(currentRound, botHand)&#10;        updateUIState {&#10;            it.copy(isChoosingStartCard = false)&#10;        }&#10;        delay(1000)&#10;        executeFirstMiniRound(takeStartCard)&#10;    }&#10;&#10;    private suspend fun executeFirstMiniRound(takeStartCard: Boolean) {&#10;        try {&#10;            currentRound?.firstMiniRound(takeStartCard)&#10;&#10;            updateUIState {&#10;                it.copy(&#10;                    gamePhase = GamePhase.PLAYING_CARDS,&#10;                    gameMessage = &quot;First mini round complete. Starting card play...&quot;,&#10;                    startCard = null&#10;                )&#10;            }&#10;&#10;            // Give initial cards to players&#10;            giveCardsToPlayers()&#10;&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error in first mini round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun giveCardsToPlayers() {&#10;        try {&#10;            currentRound?.giveCardsToPlayers()&#10;            &#10;            // Deal cards from deck to hands (3 cards each as per NUM_OF_HAND)&#10;            repeat(3) {&#10;                // Deal to player&#10;                val playerCardData = deck.dealCard()&#10;                if (playerCardData.size &gt;= 2) {&#10;                    playerHand.addCard(playerCardData[0], playerCardData[1])&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data from deck&quot;)&#10;                    }&#10;                    return&#10;                }&#10;                &#10;                // Deal to bot&#10;                val botCardData = deck.dealCard()&#10;                if (botCardData.size &gt;= 2) {&#10;                    botHand.addCard(botCardData[0], botCardData[1])  &#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data from deck&quot;)&#10;                    }&#10;                    return&#10;                }&#10;            }&#10;            &#10;            // Add cards to board (4 cards as per NUM_OF_BOARD)&#10;            repeat(4) {&#10;                val cardData = deck.dealCard()&#10;                if (cardData.size &gt;= 2) {&#10;                    board.addToBoard(cardData[0], cardData[1])&#10;                } else {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Warning: Invalid card data for board&quot;)&#10;                    }&#10;                    return&#10;                }&#10;            }&#10;            &#10;            updateGameUI()&#10;            &#10;            // Start player turns&#10;            if (game.getFirstPlayer() == Round.P1) {&#10;                updateUIState {&#10;                    it.copy(&#10;                        isPlayerTurn = true,&#10;                        gameMessage = &quot;Your turn! Play a card or drop one.&quot;&#10;                    )&#10;                }&#10;            } else {&#10;                processBotTurn()&#10;            }&#10;            &#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not available - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error giving cards: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun playCard(cardGui: CardGui, selectedTableCards: List&lt;CardGui&gt;) {&#10;        viewModelScope.launch {&#10;            if (!_uiState.value.isPlayerTurn || _uiState.value.gamePhase != GamePhase.PLAYING_CARDS) {&#10;                return@launch&#10;            }&#10;&#10;            try {&#10;                // Find card index in player hand&#10;                val cardIndex = findCardIndexInHand(cardGui, playerHand)&#10;                if (cardIndex == -1) {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Card not found in hand&quot;)&#10;                    }&#10;                    return@launch&#10;                }&#10;&#10;                // Convert selected table cards to indices&#10;                val tableCardIndices = selectedTableCards.mapNotNull { tableCard -&gt;&#10;                    board.getBoard().indexOfFirst { CardConverter.cardGuiMatchesNativeCard(tableCard, it) }.takeIf { it &gt;= 0 }&#10;                }&#10;&#10;                // Try to play the card with selected table cards&#10;                val result = playerHand.playCard(cardIndex, tableCardIndices.toIntArray(), board)&#10;&#10;                if (result == Hand.STATUS_OK)&#10;                {&#10;&#10;                    updateUIState {&#10;                        it.copy(&#10;                            gameMessage = &quot;Card played successfully!&quot;,&#10;                            isPlayerTurn = false&#10;                        )&#10;                    }&#10;                    updateGameUI()&#10;                    checkHandsAndContinue()&#10;                }&#10;                else if (result == Hand.STATUS_ERROR_NOT_FIT)&#10;                {&#10;                    playerHand.dropCard(cardIndex, board);&#10;                    updateGameUI()&#10;                    checkHandsAndContinue()&#10;                }&#10;                else&#10;                {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Cannot play this card.&quot;)&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Error playing card: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun canDropCard(selectedHandCard: CardGui?, selectedTableCards: List&lt;CardGui&gt;): Boolean {&#10;        return if (selectedHandCard == null) {&#10;            false&#10;        } else {&#10;            selectedTableCards.isEmpty() || board.getBoard().none { tableCard -&gt;&#10;                CardConverter.cardGuiMatchesNativeCard(selectedHandCard, tableCard)&#10;            }&#10;        }&#10;    }&#10;    private suspend fun processBotTurn() {&#10;        updateUIState {&#10;            it.copy(&#10;                gameMessage = &quot;Bot is thinking...&quot;,&#10;                isPlayerTurn = false&#10;            )&#10;        }&#10;        &#10;        delay(1000) // Add delay for better UX&#10;        &#10;        try {&#10;            val botMove = gameBot.makeMove(botHand, board)&#10;            &#10;            when (botMove) {&#10;                is GameBot.BotMove.PlayCard -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot played a card&quot;)&#10;                    }&#10;                }&#10;                is GameBot.BotMove.DropCard -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot dropped a card&quot;)&#10;                    }&#10;                }&#10;                is GameBot.BotMove.NoMove -&gt; {&#10;                    updateUIState {&#10;                        it.copy(gameMessage = &quot;Bot has no moves&quot;)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            updateGameUI()&#10;            checkHandsAndContinue()&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error in bot turn: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun checkHandsAndContinue() {&#10;        val playerHandSize = playerHand.getHandSize()&#10;        val botHandSize = botHand.getHandSize()&#10;        &#10;        if (playerHandSize == 0 &amp;&amp; botHandSize == 0) {&#10;            // Both hands empty - give new cards or end round&#10;            if (deckHasCards()) {&#10;                updateUIState {&#10;                    it.copy(&#10;                        gamePhase = GamePhase.GIVING_CARDS,&#10;                        gameMessage = &quot;Hands empty, dealing new cards...&quot;&#10;                    )&#10;                }&#10;                delay(1000)&#10;                giveCardsToPlayers()&#10;            } else {&#10;                // Deck is empty - end round&#10;                endRound()&#10;            }&#10;        } else {&#10;            // Continue with next player turn&#10;            val nextPlayerTurn = !_uiState.value.isPlayerTurn&#10;            updateUIState {&#10;                it.copy(isPlayerTurn = nextPlayerTurn)&#10;            }&#10;            &#10;            if (!nextPlayerTurn) {&#10;                // Bot's turn&#10;                delay(500)&#10;                processBotTurn()&#10;            } else {&#10;                updateUIState {&#10;                    it.copy(gameMessage = &quot;Your turn!&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun endRound() {&#10;        try {&#10;            currentRound?.countPiles()&#10;            &#10;            val roundP1Points = currentRound?.getP1Points() ?: 0&#10;            val roundP2Points = currentRound?.getP2Points() ?: 0&#10;            &#10;            game.addToP1Points(roundP1Points)&#10;            game.addToP2Points(roundP2Points)&#10;            &#10;            updateUIState {&#10;                it.copy(&#10;                    gamePhase = GamePhase.ROUND_COMPLETE,&#10;                    roundScore = Pair(roundP1Points, roundP2Points),&#10;                    gameScore = Pair(game.getP1Points(), game.getP2Points()),&#10;                    gameMessage = &quot;Round complete! P1: $roundP1Points, P2: $roundP2Points&quot;&#10;                )&#10;            }&#10;            &#10;            delay(2000)&#10;            &#10;            if (game.isGameOver()) {&#10;                endGame()&#10;            } else {&#10;                // Change first player and start new round&#10;                game.changeFirstPlayer()&#10;                startNewRound()&#10;            }&#10;            &#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error ending round: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endGame() {&#10;        val winner = game.getWinner()&#10;        updateUIState {&#10;            it.copy(&#10;                gamePhase = GamePhase.GAME_OVER,&#10;                winner = winner,&#10;                gameMessage = &quot;Game Over! Winner: ${winner ?: &quot;Tie&quot;}&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun findCardIndexInHand(cardGui: CardGui, hand: Hand): Int {&#10;        val handSize = hand.getHandSize()&#10;        for (i in 0 until handSize) {&#10;            val handCard = hand.getCardAsNativeCard(i)&#10;            if (handCard != null &amp;&amp; CardConverter.cardGuiMatchesNativeCard(cardGui, handCard)) {&#10;                return i&#10;            }&#10;        }&#10;        return -1&#10;    }&#10;&#10;    private fun updateGameUI() {&#10;        try {&#10;            val playerCards = playerHand.getAllCards().map { CardConverter.nativeCardToCardGui(it) }&#10;            val botCards = botHand.getAllCards().map { CardConverter.nativeCardToCardGui(it) }&#10;            val tableCards = board.getBoard().map { CardConverter.nativeCardToCardGui(it) }&#10;            &#10;            updateUIState { currentState -&gt;&#10;                currentState.copy(&#10;                    playerHand = playerCards,&#10;                    botHand = botCards,&#10;                    tableCards = tableCards&#10;                )&#10;            }&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error: Native method not available for UI update - ${e.message}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            updateUIState {&#10;                it.copy(gameMessage = &quot;Error updating game UI: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun deckHasCards(): Boolean {&#10;        return try {&#10;            deck.getDeckSize() &gt; 0&#10;        } catch (e: UnsatisfiedLinkError) {&#10;            // If native method fails, assume no cards&#10;            false&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    private inline fun updateUIState(update: (GameUIState) -&gt; GameUIState) {&#10;        _uiState.value = update(_uiState.value)&#10;    }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/shkuba/Board.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/shkuba/Board.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.dinari.shkuba&#10;&#10;class Board {&#10;    // Native pointer to the C++ Board instance&#10;    private var nativeHandle: Long = 0&#10;&#10;    init {&#10;        nativeHandle = nativeCreate()&#10;    }&#10;&#10;    // JNI: Create C++ Board instance&#10;    private external fun nativeCreate(): Long&#10;&#10;    // JNI: Clean up C++ Board instance&#10;    private external fun nativeDestroy(handle: Long)&#10;&#10;    // JNI: Get board size&#10;    external fun getBoardSize(): Int&#10;&#10;    // JNI: Add card to board&#10;    external fun addToBoard(suit: Int, rank: Int)&#10;&#10;    // JNI: Get all cards on board as array of [suit, rank] pairs&#10;    external fun getBoard(): IntArray&#10;&#10;    // Helper function to convert board data to Card objects&#10;    fun getBoardCards(): List&lt;Card&gt; {&#10;        val boardData = getBoard()&#10;        val cards = mutableListOf&lt;Card&gt;()&#10;        for (i in boardData.indices step 2) {&#10;            if (i + 1 &lt; boardData.size) {&#10;                cards.add(Card(boardData[i], boardData[i + 1]))&#10;            }&#10;        }&#10;        return cards&#10;    }&#10;&#10;    protected fun finalize() {&#10;        if (nativeHandle != 0L) {&#10;            nativeDestroy(nativeHandle)&#10;            nativeHandle = 0L&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        init {&#10;            System.loadLibrary(&quot;shkuba&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/shkuba/GameUI.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/shkuba/GameUI.kt" />
              <option name="originalContent" value="package com.dinari.shkuba&#10;&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.interaction.collectIsPressedAsState&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.foundation.horizontalScroll&#10;import com.dinari.shkuba.R&#10;&#10;// Data models&#10;sealed class Suit(val symbol: String) {&#10;    object Spades : Suit(&quot;♠&quot;)&#10;    object Diamonds : Suit(&quot;♦&quot;)&#10;    object Clubs : Suit(&quot;♣&quot;)&#10;    object Hearts : Suit(&quot;♥&quot;)&#10;}&#10;&#10;data class CardGui(val value: String, val suit: Suit) {&#10;    override fun toString(): String = &quot;$value${suit.symbol}&quot;&#10;}&#10;&#10;data class Player(val name: String, val hand: List&lt;CardGui&gt;)&#10;&#10;data class GameState(&#10;    val players: List&lt;Player&gt;,&#10;    val tableCards: List&lt;CardGui&gt;,&#10;    val currentPlayerIndex: Int&#10;)&#10;&#10;// UI Components&#10;@Composable&#10;fun CardView(&#10;    card: CardGui,&#10;    onClick: (() -&gt; Unit)? = null&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .size(70.dp, 100.dp)&#10;            .clickable(enabled = onClick != null) { onClick?.invoke() },&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.White)&#10;                .border(&#10;                    width = 1.dp,&#10;                    color = Color.Gray,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier.padding(4.dp)&#10;            ) {&#10;                Text(&#10;                    text = card.value,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 24.sp&#10;                    ),&#10;                    color = when (card.suit) {&#10;                        is Suit.Hearts, is Suit.Diamonds -&gt; Color(0xFFDC3545)&#10;                        else -&gt; Color(0xFF212529)&#10;                    }&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = card.suit.symbol,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontSize = 20.sp&#10;                    ),&#10;                    color = when (card.suit) {&#10;                        is Suit.Hearts, is Suit.Diamonds -&gt; Color(0xFFDC3545)&#10;                        else -&gt; Color(0xFF212529)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(gameState: GameState, onPlayCard: (CardGui) -&gt; Unit, onTableCardClick: (CardGui) -&gt; Unit) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0xFFE8F0FE))&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            verticalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                &quot;Shkuba Card Game&quot;,&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 28.sp&#10;                ),&#10;                color = cardTextPrimary(),&#10;                modifier = Modifier.align(Alignment.CenterHorizontally)&#10;            )&#10;&#10;            // Table section&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 16.dp)&#10;                    .shadow(8.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = cardSurface())&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        &quot;Table&quot;,&#10;                        style = MaterialTheme.typography.titleLarge.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = cardTextPrimary()&#10;                    )&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .horizontalScroll(rememberScrollState()),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        gameState.tableCards.forEach { card -&gt;&#10;                            CardView(card = card, onClick = { onTableCardClick(card) })&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Player's hand section&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 16.dp)&#10;                    .shadow(8.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = cardSurface())&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        &quot;Your Hand&quot;,&#10;                        style = MaterialTheme.typography.titleLarge.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = cardTextPrimary()&#10;                    )&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .horizontalScroll(rememberScrollState()),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        gameState.players.first().hand.forEach { card -&gt;&#10;                            CardView(card = card, onClick = { onPlayCard(card) })&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainMenu(&#10;    onStartGame: () -&gt; Unit,&#10;    onOptions: () -&gt; Unit,&#10;    onExit: () -&gt; Unit,&#10;    onPvp: () -&gt; Unit,&#10;    startGameLabel: String,&#10;    optionsLabel: String,&#10;    exitLabel: String,&#10;    titleLabel: String&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(&#10;                Brush.verticalGradient(&#10;                    colors = listOf(&#10;                        cardBackground(),&#10;                        Color(0xFFE8F0FE)&#10;                    )&#10;                )&#10;            )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.8f)&#10;                .align(Alignment.Center),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                titleLabel,&#10;                style = MaterialTheme.typography.headlineLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 42.sp,&#10;                    letterSpacing = (-1).sp&#10;                ),&#10;                color = cardTextPrimary()&#10;            )&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            MenuButton(&#10;                text = startGameLabel,&#10;                onClick = onStartGame,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardPrimary(), cardPrimaryLight())&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = optionsLabel,&#10;                onClick = onOptions,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardAccentOrange(), cardAccentOrange().copy(alpha = 0.8f))&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = exitLabel,&#10;                onClick = onExit,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(Color(0xFF6C757D), Color(0xFF495057))&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = stringResource(id = R.string.pvp),&#10;                onClick = onPvp,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardAccentGreen(), cardAccentGreen().copy(alpha = 0.8f))&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MenuButton(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    gradient: Brush&#10;) {&#10;    val interactionSource = remember { MutableInteractionSource() }&#10;    val isPressed by interactionSource.collectIsPressedAsState()&#10;&#10;    val scale = if (isPressed) 0.95f else 1f&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .graphicsLayer(scaleX = scale, scaleY = scale)&#10;            .fillMaxWidth()&#10;            .height(56.dp)&#10;            .background(gradient, RoundedCornerShape(28.dp))&#10;            .clickable(&#10;                interactionSource = interactionSource,&#10;                indication = null,&#10;                onClick = onClick&#10;            )&#10;            .border(&#10;                width = 1.dp,&#10;                color = Color.White.copy(alpha = 0.2f),&#10;                shape = RoundedCornerShape(28.dp)&#10;            )&#10;            .padding(8.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = text,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontWeight = FontWeight.SemiBold,&#10;                letterSpacing = 0.5.sp&#10;            ),&#10;            color = Color.White&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun InGameMenu(&#10;    onMainMenu: () -&gt; Unit,&#10;    onBackToGame: () -&gt; Unit,&#10;    onOptions: () -&gt; Unit,&#10;    mainMenuLabel: String,&#10;    backToGameLabel: String,&#10;    optionsLabel: String,&#10;    titleLabel: String&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0x99000000))&#10;            .clickable(&#10;                interactionSource = remember { MutableInteractionSource() },&#10;                indication = null,&#10;                onClick = onBackToGame&#10;            )&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.9f)&#10;                .align(Alignment.Center)&#10;                .clickable(enabled = false) { },&#10;            shape = RoundedCornerShape(24.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = cardSurface()&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    titleLabel,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontWeight = FontWeight.Bold&#10;                    ),&#10;                    color = cardTextPrimary()&#10;                )&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                MenuButton(&#10;                    text = mainMenuLabel,&#10;                    onClick = onMainMenu,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardPrimary(), cardPrimaryLight())&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                MenuButton(&#10;                    text = optionsLabel,&#10;                    onClick = onOptions,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardAccentOrange(), cardAccentOrange().copy(alpha = 0.8f))&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                MenuButton(&#10;                    text = backToGameLabel,&#10;                    onClick = onBackToGame,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardAccentGreen(), cardAccentGreen().copy(alpha = 0.8f))&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun OptionsScreen(&#10;    isDarkMode: Boolean,&#10;    onToggleTheme: () -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    selectedLanguage: String,&#10;    onLanguageChange: (String) -&gt; Unit,&#10;    languageOptions: List&lt;String&gt;&#10;) {&#10;    val colorScheme = MaterialTheme.colorScheme&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(&#10;                Brush.verticalGradient(&#10;                    colors = listOf(&#10;                        colorScheme.background,&#10;                        colorScheme.surface&#10;                    )&#10;                )&#10;            )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.9f)&#10;                .align(Alignment.Center),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                stringResource(id = R.string.options),&#10;                style = MaterialTheme.typography.headlineLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 36.sp,&#10;                    letterSpacing = (-0.5).sp&#10;                ),&#10;                color = colorScheme.onBackground&#10;            )&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            // Theme Switch&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;                    .shadow(4.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = colorScheme.surface)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        stringResource(id = R.string.dark_mode),&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = colorScheme.onSurface&#10;                    )&#10;                    Switch(&#10;                        checked = isDarkMode,&#10;                        onCheckedChange = { onToggleTheme() },&#10;                        colors = SwitchDefaults.colors(&#10;                            checkedThumbColor = colorScheme.primary,&#10;                            checkedTrackColor = colorScheme.primary.copy(alpha = 0.5f),&#10;                            uncheckedThumbColor = Color.Gray,&#10;                            uncheckedTrackColor = Color.LightGray&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Language Selection&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;                    .shadow(4.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = colorScheme.surface)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        stringResource(id = R.string.language),&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = colorScheme.onSurface&#10;                    )&#10;                    languageOptions.forEach { lang -&gt;&#10;                        val isSelected = lang == selectedLanguage&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(48.dp)&#10;                                .background(&#10;                                    if (isSelected) colorScheme.primary else Color.Transparent,&#10;                                    RoundedCornerShape(24.dp)&#10;                                )&#10;                                .border(&#10;                                    width = 1.dp,&#10;                                    color = if (isSelected) colorScheme.primary else colorScheme.outline,&#10;                                    shape = RoundedCornerShape(24.dp)&#10;                                )&#10;                                .clickable { onLanguageChange(lang) }&#10;                                .padding(horizontal = 16.dp),&#10;                            contentAlignment = Alignment.CenterStart&#10;                        ) {&#10;                            Text(&#10;                                lang,&#10;                                color = if (isSelected) colorScheme.onPrimary else colorScheme.onSurface,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(32.dp))&#10;&#10;            MenuButton(&#10;                text = stringResource(id = R.string.back),&#10;                onClick = onBack,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(colorScheme.secondary, colorScheme.secondary.copy(alpha = 0.8f))&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun cardTextPrimary() = MaterialTheme.colorScheme.onSurface&#10;@Composable&#10;fun cardSurface() = MaterialTheme.colorScheme.surface&#10;@Composable&#10;fun cardBackground() = MaterialTheme.colorScheme.background&#10;@Composable&#10;fun cardPrimary() = MaterialTheme.colorScheme.primary&#10;@Composable&#10;fun cardPrimaryLight() = MaterialTheme.colorScheme.primaryContainer&#10;@Composable&#10;fun cardAccentOrange() = MaterialTheme.colorScheme.secondary&#10;@Composable&#10;fun cardAccentGreen() = MaterialTheme.colorScheme.tertiary&#10;" />
              <option name="updatedContent" value="package com.dinari.shkuba&#10;&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.interaction.collectIsPressedAsState&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.foundation.horizontalScroll&#10;import com.dinari.shkuba.R&#10;&#10;// Data models&#10;sealed class Suit(val symbol: String) {&#10;    object Spades : Suit(&quot;♠&quot;)&#10;    object Diamonds : Suit(&quot;♦&quot;)&#10;    object Clubs : Suit(&quot;♣&quot;)&#10;    object Hearts : Suit(&quot;♥&quot;)&#10;}&#10;&#10;data class CardGui(val value: String, val suit: Suit) {&#10;    override fun toString(): String = &quot;$value${suit.symbol}&quot;&#10;}&#10;&#10;data class Player(val name: String, val hand: List&lt;CardGui&gt;)&#10;&#10;data class GameState(&#10;    val players: List&lt;Player&gt;,&#10;    val tableCards: List&lt;CardGui&gt;,&#10;    val currentPlayerIndex: Int&#10;)&#10;&#10;// UI Components&#10;@Composable&#10;fun CardView(&#10;    card: CardGui,&#10;    onClick: (() -&gt; Unit)? = null&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .size(70.dp, 100.dp)&#10;            .clickable(enabled = onClick != null) { onClick?.invoke() },&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.White)&#10;                .border(&#10;                    width = 1.dp,&#10;                    color = Color.Gray,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier.padding(4.dp)&#10;            ) {&#10;                Text(&#10;                    text = card.value,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 24.sp&#10;                    ),&#10;                    color = when (card.suit) {&#10;                        is Suit.Hearts, is Suit.Diamonds -&gt; Color(0xFFDC3545)&#10;                        else -&gt; Color(0xFF212529)&#10;                    }&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = card.suit.symbol,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontSize = 20.sp&#10;                    ),&#10;                    color = when (card.suit) {&#10;                        is Suit.Hearts, is Suit.Diamonds -&gt; Color(0xFFDC3545)&#10;                        else -&gt; Color(0xFF212529)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    gameState: GameState,&#10;    onPlayCard: (CardGui) -&gt; Unit,&#10;    onTableCardClick: (CardGui) -&gt; Unit,&#10;    isChoosingStartCard: Boolean = false,&#10;    startCard: CardGui? = null,&#10;    onChooseStartCard: ((Boolean) -&gt; Unit)? = null&#10;) {&#10;    if (isChoosingStartCard &amp;&amp; startCard != null &amp;&amp; onChooseStartCard != null) {&#10;        StartCardDialog(&#10;            startCard = startCard,&#10;            onTake = { onChooseStartCard(true) },&#10;            onSkip = { onChooseStartCard(false) }&#10;        )&#10;    }&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0xFFE8F0FE))&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            verticalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                &quot;Shkuba Card Game&quot;,&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 28.sp&#10;                ),&#10;                color = cardTextPrimary(),&#10;                modifier = Modifier.align(Alignment.CenterHorizontally)&#10;            )&#10;&#10;            // Table section&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 16.dp)&#10;                    .shadow(8.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = cardSurface())&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        &quot;Table&quot;,&#10;                        style = MaterialTheme.typography.titleLarge.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = cardTextPrimary()&#10;                    )&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .horizontalScroll(rememberScrollState()),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        gameState.tableCards.forEach { card -&gt;&#10;                            CardView(card = card, onClick = { onTableCardClick(card) })&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Player's hand section&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 16.dp)&#10;                    .shadow(8.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = cardSurface())&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        &quot;Your Hand&quot;,&#10;                        style = MaterialTheme.typography.titleLarge.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = cardTextPrimary()&#10;                    )&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .horizontalScroll(rememberScrollState()),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        gameState.players.first().hand.forEach { card -&gt;&#10;                            CardView(card = card, onClick = { onPlayCard(card) })&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainMenu(&#10;    onStartGame: () -&gt; Unit,&#10;    onOptions: () -&gt; Unit,&#10;    onExit: () -&gt; Unit,&#10;    onPvp: () -&gt; Unit,&#10;    startGameLabel: String,&#10;    optionsLabel: String,&#10;    exitLabel: String,&#10;    titleLabel: String&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(&#10;                Brush.verticalGradient(&#10;                    colors = listOf(&#10;                        cardBackground(),&#10;                        Color(0xFFE8F0FE)&#10;                    )&#10;                )&#10;            )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.8f)&#10;                .align(Alignment.Center),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                titleLabel,&#10;                style = MaterialTheme.typography.headlineLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 42.sp,&#10;                    letterSpacing = (-1).sp&#10;                ),&#10;                color = cardTextPrimary()&#10;            )&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            MenuButton(&#10;                text = startGameLabel,&#10;                onClick = onStartGame,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardPrimary(), cardPrimaryLight())&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = optionsLabel,&#10;                onClick = onOptions,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardAccentOrange(), cardAccentOrange().copy(alpha = 0.8f))&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = exitLabel,&#10;                onClick = onExit,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(Color(0xFF6C757D), Color(0xFF495057))&#10;                )&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            MenuButton(&#10;                text = stringResource(id = R.string.pvp),&#10;                onClick = onPvp,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(cardAccentGreen(), cardAccentGreen().copy(alpha = 0.8f))&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MenuButton(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    gradient: Brush&#10;) {&#10;    val interactionSource = remember { MutableInteractionSource() }&#10;    val isPressed by interactionSource.collectIsPressedAsState()&#10;&#10;    val scale = if (isPressed) 0.95f else 1f&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .graphicsLayer(scaleX = scale, scaleY = scale)&#10;            .fillMaxWidth()&#10;            .height(56.dp)&#10;            .background(gradient, RoundedCornerShape(28.dp))&#10;            .clickable(&#10;                interactionSource = interactionSource,&#10;                indication = null,&#10;                onClick = onClick&#10;            )&#10;            .border(&#10;                width = 1.dp,&#10;                color = Color.White.copy(alpha = 0.2f),&#10;                shape = RoundedCornerShape(28.dp)&#10;            )&#10;            .padding(8.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = text,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontWeight = FontWeight.SemiBold,&#10;                letterSpacing = 0.5.sp&#10;            ),&#10;            color = Color.White&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun InGameMenu(&#10;    onMainMenu: () -&gt; Unit,&#10;    onBackToGame: () -&gt; Unit,&#10;    onOptions: () -&gt; Unit,&#10;    mainMenuLabel: String,&#10;    backToGameLabel: String,&#10;    optionsLabel: String,&#10;    titleLabel: String&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0x99000000))&#10;            .clickable(&#10;                interactionSource = remember { MutableInteractionSource() },&#10;                indication = null,&#10;                onClick = onBackToGame&#10;            )&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.9f)&#10;                .align(Alignment.Center)&#10;                .clickable(enabled = false) { },&#10;            shape = RoundedCornerShape(24.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = cardSurface()&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    titleLabel,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontWeight = FontWeight.Bold&#10;                    ),&#10;                    color = cardTextPrimary()&#10;                )&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                MenuButton(&#10;                    text = mainMenuLabel,&#10;                    onClick = onMainMenu,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardPrimary(), cardPrimaryLight())&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                MenuButton(&#10;                    text = optionsLabel,&#10;                    onClick = onOptions,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardAccentOrange(), cardAccentOrange().copy(alpha = 0.8f))&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                MenuButton(&#10;                    text = backToGameLabel,&#10;                    onClick = onBackToGame,&#10;                    gradient = Brush.horizontalGradient(&#10;                        colors = listOf(cardAccentGreen(), cardAccentGreen().copy(alpha = 0.8f))&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun OptionsScreen(&#10;    isDarkMode: Boolean,&#10;    onToggleTheme: () -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    selectedLanguage: String,&#10;    onLanguageChange: (String) -&gt; Unit,&#10;    languageOptions: List&lt;String&gt;&#10;) {&#10;    val colorScheme = MaterialTheme.colorScheme&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(&#10;                Brush.verticalGradient(&#10;                    colors = listOf(&#10;                        colorScheme.background,&#10;                        colorScheme.surface&#10;                    )&#10;                )&#10;            )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.9f)&#10;                .align(Alignment.Center),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                stringResource(id = R.string.options),&#10;                style = MaterialTheme.typography.headlineLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 36.sp,&#10;                    letterSpacing = (-0.5).sp&#10;                ),&#10;                color = colorScheme.onBackground&#10;            )&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            // Theme Switch&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;                    .shadow(4.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = colorScheme.surface)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        stringResource(id = R.string.dark_mode),&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = colorScheme.onSurface&#10;                    )&#10;                    Switch(&#10;                        checked = isDarkMode,&#10;                        onCheckedChange = { onToggleTheme() },&#10;                        colors = SwitchDefaults.colors(&#10;                            checkedThumbColor = colorScheme.primary,&#10;                            checkedTrackColor = colorScheme.primary.copy(alpha = 0.5f),&#10;                            uncheckedThumbColor = Color.Gray,&#10;                            uncheckedTrackColor = Color.LightGray&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Language Selection&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;                    .shadow(4.dp, RoundedCornerShape(16.dp)),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = colorScheme.surface)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&#10;                        stringResource(id = R.string.language),&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontWeight = FontWeight.SemiBold&#10;                        ),&#10;                        color = colorScheme.onSurface&#10;                    )&#10;                    languageOptions.forEach { lang -&gt;&#10;                        val isSelected = lang == selectedLanguage&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(48.dp)&#10;                                .background(&#10;                                    if (isSelected) colorScheme.primary else Color.Transparent,&#10;                                    RoundedCornerShape(24.dp)&#10;                                )&#10;                                .border(&#10;                                    width = 1.dp,&#10;                                    color = if (isSelected) colorScheme.primary else colorScheme.outline,&#10;                                    shape = RoundedCornerShape(24.dp)&#10;                                )&#10;                                .clickable { onLanguageChange(lang) }&#10;                                .padding(horizontal = 16.dp),&#10;                            contentAlignment = Alignment.CenterStart&#10;                        ) {&#10;                            Text(&#10;                                lang,&#10;                                color = if (isSelected) colorScheme.onPrimary else colorScheme.onSurface,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(32.dp))&#10;&#10;            MenuButton(&#10;                text = stringResource(id = R.string.back),&#10;                onClick = onBack,&#10;                gradient = Brush.horizontalGradient(&#10;                    colors = listOf(colorScheme.secondary, colorScheme.secondary.copy(alpha = 0.8f))&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun StartCardDialog(&#10;    startCard: CardGui?,&#10;    onTake: () -&gt; Unit,&#10;    onSkip: () -&gt; Unit&#10;) {&#10;    if (startCard != null) {&#10;        AlertDialog(&#10;            onDismissRequest = {},&#10;            title = { Text(&quot;Start Card Choice&quot;) },&#10;            text = {&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Text(&quot;Do you want to take this card as one of your hand cards?&quot;)&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    CardView(card = startCard, onClick = {})&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(onClick = onTake) { Text(&quot;Take&quot;) }&#10;            },&#10;            dismissButton = {&#10;                Button(onClick = onSkip) { Text(&quot;Skip&quot;) }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun cardTextPrimary() = MaterialTheme.colorScheme.onSurface&#10;@Composable&#10;fun cardSurface() = MaterialTheme.colorScheme.surface&#10;@Composable&#10;fun cardBackground() = MaterialTheme.colorScheme.background&#10;@Composable&#10;fun cardPrimary() = MaterialTheme.colorScheme.primary&#10;@Composable&#10;fun cardPrimaryLight() = MaterialTheme.colorScheme.primaryContainer&#10;@Composable&#10;fun cardAccentOrange() = MaterialTheme.colorScheme.secondary&#10;@Composable&#10;fun cardAccentGreen() = MaterialTheme.colorScheme.tertiary" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/shkuba/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/shkuba/MainActivity.kt" />
              <option name="originalContent" value="package com.shkuba&#10;&#10;import android.content.res.Configuration&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.MutableState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.shkuba.ui.theme.ShkubaTheme&#10;import java.util.Locale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.runtime.CompositionLocalProvider&#10;import androidx.compose.runtime.key&#10;import com.dinari.shkuba.CardGui&#10;import com.dinari.shkuba.GameScreen&#10;import com.dinari.shkuba.GameState&#10;import com.dinari.shkuba.GameViewModel&#10;import com.dinari.shkuba.InGameMenu&#10;import com.dinari.shkuba.MainMenu&#10;import com.dinari.shkuba.OptionsScreen&#10;import com.dinari.shkuba.Player&#10;import com.dinari.shkuba.R&#10;import com.shkuba.ui.PvpPlayerListScreen&#10;import com.shkuba.network.NetworkService&#10;&#10;class MainActivity : ComponentActivity() {&#10;    companion object {&#10;        private var libraryLoaded = false&#10;        &#10;        init {&#10;            try {&#10;                System.loadLibrary(&quot;shkuba&quot;)&#10;                libraryLoaded = true&#10;            } catch (e: UnsatisfiedLinkError) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;Failed to load native library: ${e.message}&quot;)&#10;                libraryLoaded = false&#10;            }&#10;        }&#10;        &#10;        fun isLibraryLoaded(): Boolean = libraryLoaded&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        &#10;        // Check if native library loaded successfully&#10;        if (!isLibraryLoaded()) {&#10;            Log.e(&quot;MainActivity&quot;, &quot;Native library failed to load. Some features may not work.&quot;)&#10;        }&#10;        &#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val isDarkMode = remember { mutableStateOf(false) }&#10;            val localeState = remember { mutableStateOf(Locale.getDefault()) }&#10;            val context = LocalContext.current&#10;            val config = Configuration(context.resources.configuration)&#10;            config.setLocale(localeState.value)&#10;            val localizedContext = context.createConfigurationContext(config)&#10;            CompositionLocalProvider(LocalContext provides localizedContext) {&#10;                ShkubaTheme(darkTheme = isDarkMode.value, dynamicColor = false) {&#10;                    MainScreen(&#10;                        onExit = { finish() },&#10;                        isDarkMode = isDarkMode,&#10;                        localeState = localeState&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        // Example: Connect player with a hardcoded name&#10;        NetworkService.connectPlayer(&quot;Player1&quot;)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(onExit: () -&gt; Unit, isDarkMode: MutableState&lt;Boolean&gt;, localeState: MutableState&lt;Locale&gt;) {&#10;    val showMenu = remember { mutableStateOf(true) }&#10;    val showOptions = remember { mutableStateOf(false) }&#10;    val showInGameMenu = remember { mutableStateOf(false) }&#10;    val showPvpList = remember { mutableStateOf(false) }&#10;    val gameViewModel: GameViewModel = viewModel()&#10;    val gameUiState by gameViewModel.uiState.collectAsState()&#10;    &#10;    val supportedLanguages = listOf(&quot;English&quot;, &quot;Hebrew&quot;, &quot;Hindi&quot;)&#10;    val languageToLocale = mapOf(&#10;        &quot;English&quot; to Locale(&quot;en&quot;),&#10;        &quot;Hebrew&quot; to Locale(&quot;iw&quot;),&#10;        &quot;Hindi&quot; to Locale(&quot;hi&quot;)&#10;    )&#10;    val selectedLanguage = remember { mutableStateOf(&#10;        languageToLocale.entries.find { it.value.language == localeState.value.language }?.key ?: &quot;English&quot;&#10;    ) }&#10;&#10;    Surface(modifier = Modifier.fillMaxSize()) {&#10;        when {&#10;            showOptions.value -&gt; {&#10;                key(localeState.value) {&#10;                    OptionsScreen(&#10;                        isDarkMode = isDarkMode.value,&#10;                        onToggleTheme = { isDarkMode.value = !isDarkMode.value },&#10;                        onBack = { showOptions.value = false },&#10;                        selectedLanguage = selectedLanguage.value,&#10;                        onLanguageChange = { lang: String -&gt;&#10;                            selectedLanguage.value = lang&#10;                            val locale = languageToLocale[lang] ?: Locale(&quot;en&quot;)&#10;                            localeState.value = locale&#10;                        },&#10;                        languageOptions = supportedLanguages&#10;                    )&#10;                }&#10;            }&#10;            showPvpList.value -&gt; {&#10;                PvpPlayerListScreen(onBack = { showPvpList.value = false; showMenu.value = true })&#10;            }&#10;            showMenu.value -&gt; {&#10;                MainMenu(&#10;                    onStartGame = {&#10;                        gameViewModel.startNewGame()&#10;                        showMenu.value = false&#10;                    },&#10;                    onOptions = { showOptions.value = true },&#10;                    onExit = onExit,&#10;                    onPvp = { showMenu.value = false; showPvpList.value = true },&#10;                    startGameLabel = stringResource(R.string.start_game),&#10;                    optionsLabel = stringResource(R.string.options),&#10;                    exitLabel = stringResource(R.string.exit),&#10;                    titleLabel = stringResource(R.string.app_name)&#10;                )&#10;            }&#10;            showInGameMenu.value -&gt; {&#10;                InGameMenu(&#10;                    onMainMenu = {&#10;                        showMenu.value = true&#10;                        showInGameMenu.value = false&#10;                    },&#10;                    onBackToGame = { showInGameMenu.value = false },&#10;                    onOptions = {&#10;                        showOptions.value = true&#10;                        showInGameMenu.value = false&#10;                    },&#10;                    mainMenuLabel = stringResource(R.string.main_menu),&#10;                    backToGameLabel = stringResource(R.string.back_to_game),&#10;                    optionsLabel = stringResource(R.string.options),&#10;                    titleLabel = stringResource(R.string.game_menu)&#10;                )&#10;            }&#10;            gameUiState.isGameActive -&gt; {&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    val selectedCard = remember { mutableStateOf&lt;CardGui?&gt;(null) }&#10;                    val selectedTableCards = remember { mutableStateOf&lt;List&lt;CardGui&gt;&gt;(emptyList()) }&#10;&#10;                    GameScreen(&#10;                        gameState = GameState(&#10;                            players = listOf(&#10;                                Player(&quot;You&quot;, gameUiState.playerHand),&#10;                                Player(&quot;Bot&quot;, emptyList()) // Don't show bot's cards&#10;                            ),&#10;                            tableCards = gameUiState.tableCards,&#10;                            currentPlayerIndex = 0 // Always show player's perspective&#10;                        ),&#10;                        onPlayCard = { card -&gt;&#10;                            if (gameUiState.isPlayerTurn) {&#10;                                selectedCard.value = card // Select the card when clicked&#10;                                selectedTableCards.value = emptyList() // Clear table card selection&#10;                            }&#10;                        },&#10;                        onTableCardClick = { tableCard: CardGui -&gt;&#10;                            if (selectedCard.value != null) {&#10;                                val currentSelection = selectedTableCards.value.toMutableList()&#10;                                if (currentSelection.contains(tableCard)) {&#10;                                    currentSelection.remove(tableCard) // Deselect if already selected&#10;                                } else {&#10;                                    currentSelection.add(tableCard) // Add to selection&#10;                                }&#10;                                selectedTableCards.value = currentSelection&#10;                            }&#10;                        }&#10;                    )&#10;&#10;                    // Game controls&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .align(Alignment.TopEnd)&#10;                            .padding(16.dp)&#10;                    )&#10;                    {&#10;                        Button(&#10;                            onClick = { showInGameMenu.value = true }&#10;                        ) {&#10;                            Text(stringResource(R.string.options))&#10;                        }&#10;&#10;                    // Drop card button&#10;                    if (gameUiState.isPlayerTurn &amp;&amp; gameViewModel.canDropCard(selectedCard.value, selectedTableCards.value)) {&#10;                        Spacer(modifier = Modifier.height(32.dp))&#10;                        Button(&#10;                            onClick = {&#10;                                selectedCard.value?.let { card -&gt;&#10;                                    gameViewModel.playCard(card, selectedTableCards.value)&#10;                                    selectedCard.value = null // Reset selection after playing&#10;                                    selectedTableCards.value = emptyList() // Clear table card selection&#10;                                }&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Play Card&quot;)&#10;                        }&#10;                    }&#10;                        }&#10;                    &#10;                    // Game status&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .align(Alignment.TopStart)&#10;                            .padding(32.dp)&#10;                    ) {&#10;                        Text(&quot;Score: ${gameUiState.gameScore.first} - ${gameUiState.gameScore.second}&quot;)&#10;                        Text(gameUiState.gameMessage)&#10;                        if (!gameUiState.isPlayerTurn) {&#10;                            Text(&quot;Bot's turn...&quot;)&#10;                        }&#10;                        if (gameUiState.winner != null) {&#10;                            Text(&quot;Winner: ${gameUiState.winner}&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.shkuba&#10;&#10;import android.content.res.Configuration&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.MutableState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.shkuba.ui.theme.ShkubaTheme&#10;import java.util.Locale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.runtime.CompositionLocalProvider&#10;import androidx.compose.runtime.key&#10;import com.dinari.shkuba.CardGui&#10;import com.dinari.shkuba.GameScreen&#10;import com.dinari.shkuba.GameState&#10;import com.dinari.shkuba.GameViewModel&#10;import com.dinari.shkuba.InGameMenu&#10;import com.dinari.shkuba.MainMenu&#10;import com.dinari.shkuba.OptionsScreen&#10;import com.dinari.shkuba.Player&#10;import com.dinari.shkuba.R&#10;import com.shkuba.ui.PvpPlayerListScreen&#10;import com.shkuba.network.NetworkService&#10;&#10;class MainActivity : ComponentActivity() {&#10;    companion object {&#10;        private var libraryLoaded = false&#10;        &#10;        init {&#10;            try {&#10;                System.loadLibrary(&quot;shkuba&quot;)&#10;                libraryLoaded = true&#10;            } catch (e: UnsatisfiedLinkError) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;Failed to load native library: ${e.message}&quot;)&#10;                libraryLoaded = false&#10;            }&#10;        }&#10;        &#10;        fun isLibraryLoaded(): Boolean = libraryLoaded&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        &#10;        // Check if native library loaded successfully&#10;        if (!isLibraryLoaded()) {&#10;            Log.e(&quot;MainActivity&quot;, &quot;Native library failed to load. Some features may not work.&quot;)&#10;        }&#10;        &#10;        enableEdgeToEdge()&#10;        setContent {&#10;            val isDarkMode = remember { mutableStateOf(false) }&#10;            val localeState = remember { mutableStateOf(Locale.getDefault()) }&#10;            val context = LocalContext.current&#10;            val config = Configuration(context.resources.configuration)&#10;            config.setLocale(localeState.value)&#10;            val localizedContext = context.createConfigurationContext(config)&#10;            CompositionLocalProvider(LocalContext provides localizedContext) {&#10;                ShkubaTheme(darkTheme = isDarkMode.value, dynamicColor = false) {&#10;                    MainScreen(&#10;                        onExit = { finish() },&#10;                        isDarkMode = isDarkMode,&#10;                        localeState = localeState&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        // Example: Connect player with a hardcoded name&#10;        NetworkService.connectPlayer(&quot;Player1&quot;)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(onExit: () -&gt; Unit, isDarkMode: MutableState&lt;Boolean&gt;, localeState: MutableState&lt;Locale&gt;) {&#10;    val showMenu = remember { mutableStateOf(true) }&#10;    val showOptions = remember { mutableStateOf(false) }&#10;    val showInGameMenu = remember { mutableStateOf(false) }&#10;    val showPvpList = remember { mutableStateOf(false) }&#10;    val gameViewModel: GameViewModel = viewModel()&#10;    val gameUiState by gameViewModel.uiState.collectAsState()&#10;    &#10;    val supportedLanguages = listOf(&quot;English&quot;, &quot;Hebrew&quot;, &quot;Hindi&quot;)&#10;    val languageToLocale = mapOf(&#10;        &quot;English&quot; to Locale(&quot;en&quot;),&#10;        &quot;Hebrew&quot; to Locale(&quot;iw&quot;),&#10;        &quot;Hindi&quot; to Locale(&quot;hi&quot;)&#10;    )&#10;    val selectedLanguage = remember { mutableStateOf(&#10;        languageToLocale.entries.find { it.value.language == localeState.value.language }?.key ?: &quot;English&quot;&#10;    ) }&#10;&#10;    Surface(modifier = Modifier.fillMaxSize()) {&#10;        when {&#10;            showOptions.value -&gt; {&#10;                key(localeState.value) {&#10;                    OptionsScreen(&#10;                        isDarkMode = isDarkMode.value,&#10;                        onToggleTheme = { isDarkMode.value = !isDarkMode.value },&#10;                        onBack = { showOptions.value = false },&#10;                        selectedLanguage = selectedLanguage.value,&#10;                        onLanguageChange = { lang: String -&gt;&#10;                            selectedLanguage.value = lang&#10;                            val locale = languageToLocale[lang] ?: Locale(&quot;en&quot;)&#10;                            localeState.value = locale&#10;                        },&#10;                        languageOptions = supportedLanguages&#10;                    )&#10;                }&#10;            }&#10;            showPvpList.value -&gt; {&#10;                PvpPlayerListScreen(onBack = { showPvpList.value = false; showMenu.value = true })&#10;            }&#10;            showMenu.value -&gt; {&#10;                MainMenu(&#10;                    onStartGame = {&#10;                        gameViewModel.startNewGame()&#10;                        showMenu.value = false&#10;                    },&#10;                    onOptions = { showOptions.value = true },&#10;                    onExit = onExit,&#10;                    onPvp = { showMenu.value = false; showPvpList.value = true },&#10;                    startGameLabel = stringResource(R.string.start_game),&#10;                    optionsLabel = stringResource(R.string.options),&#10;                    exitLabel = stringResource(R.string.exit),&#10;                    titleLabel = stringResource(R.string.app_name)&#10;                )&#10;            }&#10;            showInGameMenu.value -&gt; {&#10;                InGameMenu(&#10;                    onMainMenu = {&#10;                        showMenu.value = true&#10;                        showInGameMenu.value = false&#10;                    },&#10;                    onBackToGame = { showInGameMenu.value = false },&#10;                    onOptions = {&#10;                        showOptions.value = true&#10;                        showInGameMenu.value = false&#10;                    },&#10;                    mainMenuLabel = stringResource(R.string.main_menu),&#10;                    backToGameLabel = stringResource(R.string.back_to_game),&#10;                    optionsLabel = stringResource(R.string.options),&#10;                    titleLabel = stringResource(R.string.game_menu)&#10;                )&#10;            }&#10;            gameUiState.isGameActive -&gt; {&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    val selectedCard = remember { mutableStateOf&lt;CardGui?&gt;(null) }&#10;                    val selectedTableCards = remember { mutableStateOf&lt;List&lt;CardGui&gt;&gt;(emptyList()) }&#10;&#10;                    GameScreen(&#10;                        gameState = GameState(&#10;                            players = listOf(&#10;                                Player(&quot;You&quot;, gameUiState.playerHand),&#10;                                Player(&quot;Bot&quot;, emptyList())&#10;                            ),&#10;                            tableCards = gameUiState.tableCards,&#10;                            currentPlayerIndex = 0&#10;                        ),&#10;                        onPlayCard = { card -&gt;&#10;                            if (gameUiState.isPlayerTurn) {&#10;                                selectedCard.value = card&#10;                                selectedTableCards.value = emptyList()&#10;                            }&#10;                        },&#10;                        onTableCardClick = { tableCard: CardGui -&gt;&#10;                            if (selectedCard.value != null) {&#10;                                val currentSelection = selectedTableCards.value.toMutableList()&#10;                                if (currentSelection.contains(tableCard)) {&#10;                                    currentSelection.remove(tableCard)&#10;                                } else {&#10;                                    currentSelection.add(tableCard)&#10;                                }&#10;                                selectedTableCards.value = currentSelection&#10;                            }&#10;                        },&#10;                        isChoosingStartCard = gameUiState.isChoosingStartCard,&#10;                        startCard = gameUiState.startCard,&#10;                        onChooseStartCard = { take -&gt;&#10;                            gameViewModel.onUserChooseStartCard(take)&#10;                        }&#10;                    )&#10;&#10;                    // Game controls&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .align(Alignment.TopEnd)&#10;                            .padding(16.dp)&#10;                    )&#10;                    {&#10;                        Button(&#10;                            onClick = { showInGameMenu.value = true }&#10;                        ) {&#10;                            Text(stringResource(R.string.options))&#10;                        }&#10;&#10;                    // Drop card button&#10;                    if (gameUiState.isPlayerTurn &amp;&amp; gameViewModel.canDropCard(selectedCard.value, selectedTableCards.value)) {&#10;                        Spacer(modifier = Modifier.height(32.dp))&#10;                        Button(&#10;                            onClick = {&#10;                                selectedCard.value?.let { card -&gt;&#10;                                    gameViewModel.playCard(card, selectedTableCards.value)&#10;                                    selectedCard.value = null // Reset selection after playing&#10;                                    selectedTableCards.value = emptyList() // Clear table card selection&#10;                                }&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Play Card&quot;)&#10;                        }&#10;                    }&#10;                        }&#10;                    &#10;                    // Game status&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .align(Alignment.TopStart)&#10;                            .padding(32.dp)&#10;                    ) {&#10;                        Text(&quot;Score: ${gameUiState.gameScore.first} - ${gameUiState.gameScore.second}&quot;)&#10;                        Text(gameUiState.gameMessage)&#10;                        if (!gameUiState.isPlayerTurn) {&#10;                            Text(&quot;Bot's turn...&quot;)&#10;                        }&#10;                        if (gameUiState.winner != null) {&#10;                            Text(&quot;Winner: ${gameUiState.winner}&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;    repositories {&#10;        // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;}&#10;&#10;allprojects {&#10;    // Removed repository declarations to avoid conflict with settings.gradle.kts&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>